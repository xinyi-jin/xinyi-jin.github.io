<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git ssh连接</title>
    <link href="/2022/09/13/github-ssh/"/>
    <url>/2022/09/13/github-ssh/</url>
    
    <content type="html"><![CDATA[<p>github ssh</p><ol><li>// 配置git用户</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;iezhuhe@163.com&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xinyi-jin&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>// genssh</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;iezhuhe@163.com&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>// verssh</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go源码阅读</title>
    <link href="/2022/09/13/Go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/09/13/Go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>Go 源码阅读<br>fmt：</p><p>rand:</p><p>​    Top Function level 简单思路阅读 未深究数据 只阅读了核心思想</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2022/08/23/test/"/>
    <url>/2022/08/23/test/</url>
    
    <content type="html"><![CDATA[<p>这里是公众号「宫水三叶的刷题日记」的 Github 仓库 🎉🎉</p><p><img src="https://github-readme-stats.vercel.app/api?username=SharingSource&show_icons=true&theme=default" alt="Anurag&#39;s GitHub stats"></p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/23/hello-world/"/>
    <url>/2022/08/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自学习内容</title>
    <link href="/2022/08/23/docker/"/>
    <url>/2022/08/23/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>docker容器不保持任何数据<br>重要数据请使用外部卷存储（数据持久化）<br>容器可以挂载真实机目录或共享存储为卷</p><h3 id="主机卷映射："><a href="#主机卷映射：" class="headerlink" title="主机卷映射："></a>主机卷映射：</h3><ul><li>宿主机到docker容器映射：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">docker run -it -v /<span class="hljs-keyword">var</span>/data:/abc myos<br></code></pre></td></tr></table></figure><ul><li>自定义容器内部网络</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create <span class="hljs-attribute">--subnet</span>=172.18.0.0/16 mynet<br></code></pre></td></tr></table></figure><ul><li>使用自定义网络运行容器,再次重启时就不会按照启动顺序分配172.17.0.1网段的ip地址了</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -itd <span class="hljs-params">--name</span> vm  <span class="hljs-params">--net</span> bind <span class="hljs-params">--ip</span> 172.18.0.103 centos <span class="hljs-string">/sbin/init</span><br></code></pre></td></tr></table></figure><p>原文地址：<a href="https://cloud.tencent.com/developer/article/1966389">https://cloud.tencent.com/developer/article/1966389</a></p><h2 id="修复-“Error-Failed-to-download-metadata-for-repo-appstream”-–-CentOS-8系统错误"><a href="#修复-“Error-Failed-to-download-metadata-for-repo-appstream”-–-CentOS-8系统错误" class="headerlink" title="修复: “Error: Failed to download metadata for repo appstream” – CentOS 8系统错误"></a>修复: “Error: Failed to download metadata for repo appstream” – CentOS 8系统错误</h2><p><strong>解决方案：迁移到 CentOS Stream 8 或替代发行版</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">dnf</span> <span class="hljs-built_in">--disablerepo</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">--enablerepo=extras</span> <span class="hljs-string">swap</span> <span class="hljs-string">centos-linux-repos</span> <span class="hljs-string">centos-stream-repos</span> <br><span class="hljs-string">dnf</span> <span class="hljs-string">distro-sync</span><br></code></pre></td></tr></table></figure><p>docker 桥接方式映射宿主机IP端口，并挂载宿主机文件卷，初始化容器环境，赋予最高操作权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -itd --name goservice -p <span class="hljs-number">41002</span>:<span class="hljs-number">31002</span> -p <span class="hljs-number">10989</span>:<span class="hljs-number">9898</span> --privileged -v <span class="hljs-regexp">/root/</span>hn_match_debug<span class="hljs-regexp">/:/</span>root<span class="hljs-regexp">/hn_match_debug/</span> centos <span class="hljs-regexp">/sbin/i</span>nit<br></code></pre></td></tr></table></figure><p>注册mongod服务</p><p>mogod.conf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># ip</span><br><br><span class="hljs-attr">bind_ip</span>=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><br><span class="hljs-comment"># mongodb port number</span><br><br><span class="hljs-attr">port</span>=<span class="hljs-number">27017</span><br><br><span class="hljs-comment"># mongodb data file path</span><br><br><span class="hljs-attr">dbpath</span>=/var/lib/mongo<br><br><span class="hljs-comment"># mongodb log file path</span><br><br><span class="hljs-attr">logpath</span>=/var/log/mongodb/mongod.log<br><br><span class="hljs-comment"># mongodb automatically append log files</span><br><br><span class="hljs-attr">logappend</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>mongod</p><p>进入 /etc/init.d/ 目录<br><code># cd /etc/init.d/</code><br>创建并编辑mongodb文件<br><code># vim mongodb</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#chkconfig:345 61 61</span><br><span class="hljs-comment">#description:mongod</span><br><br><span class="hljs-comment"># mongoDB shell version v5.0.9</span><br><br><span class="hljs-comment"># connecting to: mongodb://0.0.0.0:27017</span><br><br><span class="hljs-comment"># MongoDB server version: 5.0.9</span><br><br>MONGO_PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mongodb5/</span>bin/mongod<br>MONGO_PID=`ps -ef|grep <span class="hljs-string">&#x27;mongod&#x27;</span> | grep -v grep|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br>test -x <span class="hljs-variable">$MONGO_PATH</span> || <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br><br>case <span class="hljs-string">&quot;$1&quot;</span> <span class="hljs-keyword">in</span><br>  start)<br>     ulimit -n <span class="hljs-number">2000</span><br>     echo <span class="hljs-string">&quot;starting mongod server&quot;</span><br>     <span class="hljs-variable">$MONGO_PATH</span> --fork --quiet -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mongodb5/m</span>ongod.conf<br>     echo <span class="hljs-string">&quot;started mongod server&quot;</span><br>     ;;<br>  stop)<br>     echo <span class="hljs-string">&quot;stopping mongod server&quot;</span><br>     <span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;$MONGO_PID&quot;</span> ]; then<br>        kill -<span class="hljs-number">15</span> <span class="hljs-variable">$MONGO_PID</span><br>     fi<br>        echo <span class="hljs-string">&quot;stopped mongod server&quot;</span><br>     ;;<br>  status)<br>     ;;<br>  *)<br>     echo <span class="hljs-string">&quot;usage: mongod &#123;start|stop|status&#125;&quot;</span><br>     <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>esac<br><br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述文件配置完成后，执行一下几条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x /etc/init.d/mongod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">chkconfig --add mongod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">chkconfig mongod on</span><br></code></pre></td></tr></table></figure><p>启动时去除ip绑定</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mongod</span> --bind_ip <span class="hljs-number">0.0.0.0</span><br></code></pre></td></tr></table></figure><h2 id="一：通过修改配置文件修改docker容器端口映射"><a href="#一：通过修改配置文件修改docker容器端口映射" class="headerlink" title="一：通过修改配置文件修改docker容器端口映射"></a>一：通过修改配置文件修改docker容器端口映射</h2><p>1.使用<strong>docker ps -a</strong>命令找到要修改容器的<strong>CONTAINER ID</strong></p><p>2.运行以下命令，进入该容器目录</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">docker inspect【CONTAINER ID】| grep Id<br>cd /var/lib/docker/containers<br></code></pre></td></tr></table></figure><p>2.停止容器</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker stop [容器id]<br></code></pre></td></tr></table></figure><p>3.停止主机docker服务</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">systemctl stop docker<br></code></pre></td></tr></table></figure><p>4.进入2得到的文件夹内，修改hostconfig.json 和 config.v2.json</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">vi hostconfig.json<br><br>比如新增一个 80 端口，在PortBindings下边添加以下内容，端口配置之间用英文字符逗号隔开<br><br>&quot;80/tcp&quot;: [ <br>&#123;<br> &quot;HostIp&quot;: &quot;0.0.0.0&quot;,<br> &quot;HostPort&quot;: &quot;80&quot;<br> &#125;<br>]<br>接着修改vi config.v2.json, 找到ExposedPorts和Ports  仿照之前内容添加端口映射<br>&quot;ExposedPorts&quot;:  &#123;<br>    &quot;2000/tcp&quot;:   &#123;&#125;<br>&#125;,<br><br>&quot;Ports&quot;:&#123;<br>   &quot;2000/tcp&quot;:[<br>        &#123;<br>         &quot;HostIp&quot;: &quot;0.0.0.0&quot;,<br>         &quot;HostPort&quot;:  &quot;2000&quot;<br>         &#125;<br>]<br>&#125;,<br></code></pre></td></tr></table></figure><p>5.保存之后重启docker服务和容器</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">systemctl start docker<br>docker start [docker id]<br></code></pre></td></tr></table></figure><h2 id="二：把运行中的容器生成新的镜像，再新建容器"><a href="#二：把运行中的容器生成新的镜像，再新建容器" class="headerlink" title="二：把运行中的容器生成新的镜像，再新建容器"></a>二：把运行中的容器生成新的镜像，再新建容器</h2><p>1.提交一个运行中的容器为镜像</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker commit [containerid] [new_imagename]<br></code></pre></td></tr></table></figure><p>2.运行新建的镜像并添加端口映射</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker run -d -p 8000:80  [imagename] /bin/sh<br></code></pre></td></tr></table></figure><h2 id="三：修改主机iptables端口映射"><a href="#三：修改主机iptables端口映射" class="headerlink" title="三：修改主机iptables端口映射"></a>三：修改主机iptables端口映射</h2><blockquote><p>docker的端口映射并不是在docker技术中实现的，而是通过宿主机的iptables来实现。通过控制网桥来做端口映射，类似路由器中设置路由端口映射。</p></blockquote><p>如果我们有一个容器的8000端口映射到主机的9000端口，先查看iptabes设置了什么规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -vnL<br></code></pre></td></tr></table></figure><p>结果中有一条：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Chain DOCKER (2 references)<br>pkts bytes target prot opt in     out     source        destination         <br> 98  5872 RETURN  all  --  docker0 *     0.0.0.0/0     0.0.0.0/0           <br>237 14316 DNAT    tcp  --  !docker0 *    0.0.0.0/0    0.0.0.0/0    tcp dpt:9000 to:172.17.0.3:8000<br></code></pre></td></tr></table></figure><p>我们可以看到docker创建了一个名为DOKCER的自定义的链条Chain。而我开放8000端口的容器的ip是172.17.0.3。</p><p>也可以通过inspect命令查看容器ip</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker inspect [containerId] |grep IPAddress<br></code></pre></td></tr></table></figure><p>我们想再增加一个端口映射，比如<code>8081-&gt;81</code>，就在这个链条是再加一条规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -A  DOCKER -p tcp --dport 8081 -j DNAT --to-destination 172.17.0.3:81<br></code></pre></td></tr></table></figure><p>加错了或者想修改：先显示行号查看</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -vnL DOCKER --line-number<br></code></pre></td></tr></table></figure><p>删除规则3</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -D DOCKER 3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件整理</title>
    <link href="/2022/03/27/%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <url>/2022/03/27/%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="文件整理"><a href="#文件整理" class="headerlink" title="文件整理"></a>文件整理</h1><h2 id="2022-03-27"><a href="#2022-03-27" class="headerlink" title="2022.03.27"></a>2022.03.27</h2><hr><ol><li>软件安装包</li><li>文档记录</li><li>源码文件</li><li>资源列表</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学习内容</title>
    <link href="/2021/10/12/%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/"/>
    <url>/2021/10/12/%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>需要学习的地方：<br>老系统 网关服务与多个服务器之间的调度 gate center login game</p><p>中心服务 拥有网关服务 登陆服务 游戏服务 连接 可以暂时理解为 中心化部署的分布式服务 可动态添加网关服务 以及各个网关主机服务所拥有的 登陆和游戏服务器</p><p>gate 连接 中心服务<br>db 注册rpc<br>center 中心服务 启动rpc服务 http服务 开启其他服务注册监听<br>login 初始化nats 注册到center </p><h1 id="2021-10-12"><a href="#2021-10-12" class="headerlink" title="2021.10.12"></a>2021.10.12</h1><p>开始首局游戏的时候,预留客户端加载资源时间 6s</p><p>引用外部包的时候时候可以更改别人包中代码，只要本地一直有修改过的版本即可，否则拉取的是外部包最新代码，没有自己修改过的版本内容。</p><p>nats相关文档</p><p>mysql 57与8.0版本差异<br>速度 默认字符集格式</p><p>什么算作代码整洁，代码整洁与性能优先考虑点 可阅读代码整洁之道 寻求答案</p><p>为什么系统中同时存在nsq和nats的使用 (nats不支持持久化)</p><p>有时间可以阅读的源码库：<br>cache2go  临时内存缓冲使用<br>gob    rpc数据传输封装</p><p>Go源码 尽快找时间阅读</p><p>archive<br>bufio<br>bulitin<br>bytes<br>cmd<br>compress<br>container<br>context<br>crypto<br>database<br>debug<br>encoding<br>errors<br>expvar<br>flag<br>fmt<br>go<br>hash<br>html<br>image<br>index<br>internal<br>io<br>log<br>math<br>mime<br>net<br>os<br>path<br>plugin<br>reflect<br>regexp<br>runtime<br>sort<br>strconv<br>strings<br>sync<br>syscall<br>testdata<br>testing<br>text<br>time<br>unicode<br>unsafe<br>vendor</p><h1 id="2021-11-23"><a href="#2021-11-23" class="headerlink" title="2021.11.23"></a>2021.11.23</h1><p>数据结构：</p><ul><li>数组  <a href="https://en.wikipedia.org/wiki/Array_data_structure">https://en.wikipedia.org/wiki/Array_data_structure</a></li><li>树 <a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">https://en.wikipedia.org/wiki/Tree_%28data_structure%29</a></li><li>栈 <a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29</a></li><li>队列 <a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29</a></li><li>图 <a href="https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29</a></li><li>哈希表 <a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a></li><li>链表 <a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a></li><li>堆 <a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29">https://en.wikipedia.org/wiki/Heap_%28data_structure%29</a></li></ul><p>算法：</p><ol><li></li></ol><p>面试题相关问题</p><p>1、golang 中 make 和 new 的区别？（基本必问）</p><p>​    make 用于slice map channel 类型的创建以及初始化，返回的是对应类型</p><p>​    new 用于分配内存空间，返回对应类型的内存指针地址</p><p>2、数组和切片的区别 （基本必问）</p><p>​    数组是固定长度的，值类型</p><p>​    切片是可变长度的，引用类型</p><p>3、for range 的时候它的地址会发生变化么？</p><p>​    会，for range 的时候操作的是拷贝的数据</p><p>​    for range 对map类型遍历时候，改变map中键值的话，会影响到输出结果，可能输出改变后的值，也可能不输出或少输出</p><p>4、go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</p><p>​    a.多个defer会倒叙返回，相当于压栈 弹栈操作；</p><h3 id="坑1：defer在匿名返回值和命名返回值函数中的不同表现"><a href="#坑1：defer在匿名返回值和命名返回值函数中的不同表现" class="headerlink" title="坑1：defer在匿名返回值和命名返回值函数中的不同表现"></a>坑1：defer在匿名返回值和命名返回值函数中的不同表现</h3><p>要搞清这个问题首先需要了解defer的执行逻辑，文档中说defer语句在方法返回“时”触发，也就是说return和defer是“同时”执行的。以匿名返回值方法举例，过程如下。</p><ul><li>将result赋值给返回值（可以理解成Go自动创建了一个返回值retValue，相当于执行retValue = result）</li><li>然后检查是否有defer，如果有则执行</li><li>返回刚才创建的返回值（retValue）</li></ul><p>在这种情况下，defer中的修改是对result执行的，而不是retValue，所以defer返回的依然是retValue。在命名返回值方法中，由于返回值在方法定义时已经被定义，所以没有创建retValue的过程，result就是retValue，defer对于result的修改也会被直接返回。</p><h3 id="坑2：在for循环中使用defer可能导致的性能问题"><a href="#坑2：在for循环中使用defer可能导致的性能问题" class="headerlink" title="坑2：在for循环中使用defer可能导致的性能问题"></a>坑2：在for循环中使用defer可能导致的性能问题</h3><p>defer在紧邻创建资源的语句后生命力，看上去逻辑没有什么问题。但是和直接调用相比，defer的执行存在着额外的开销，例如defer会对其后需要的参数进行内存拷贝，还需要对defer结构进行压栈出栈操作。所以在循环中定义defer可能导致大量的资源开销，在本例中，可以将f.Close()语句前的defer去掉，来减少大量defer导致的额外资源消耗。</p><h3 id="坑3：判断执行没有err之后，再defer释放资源"><a href="#坑3：判断执行没有err之后，再defer释放资源" class="headerlink" title="坑3：判断执行没有err之后，再defer释放资源"></a>坑3：判断执行没有err之后，再defer释放资源</h3><p>一些获取资源的操作可能会返回err参数，我们可以选择忽略返回的err参数，但是如果要使用defer进行延迟释放的的话，需要在使用defer之前先判断是否存在err，如果资源没有获取成功，即没有必要也不应该再对资源执行释放操作。如果不判断获取资源是否成功就执行释放操作的话，还有可能导致释放方法执行错误。</p><h3 id="坑4：调用os-Exit时defer不会被执行"><a href="#坑4：调用os-Exit时defer不会被执行" class="headerlink" title="坑4：调用os.Exit时defer不会被执行"></a>坑4：调用os.Exit时defer不会被执行</h3><p>当发生panic时，所在goroutine的所有defer会被执行，但是当调用os.Exit()方法退出程序时，defer并不会被执行。</p><p>5、 uint 类型溢出</p><p>​    数值类型溢出的时候，会重置为0</p><p>6、介绍 rune 类型</p><p>​    rune 相当于int32，特殊的字节类型  可以表示中文字符</p><p>​    uint8 表示一般字符</p><h1 id="2021-11-23-1"><a href="#2021-11-23-1" class="headerlink" title="2021.11.23"></a>2021.11.23</h1><p>设计模式：</p><p>开闭原则：对拓展开放，对修改关闭。</p><p>里氏换元原则：父类可调用的方法，子类也可调用。继承</p><p>OOP 四大特性：封装、继承、多态、抽象</p><p>创建型模式：创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p><ol><li><p>工厂模式：对象的创建和使用分离。</p></li><li><p>抽象工厂模式：通过传递参数获取实体类的对象。意图提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p>单例模式：实例只创建一次，常存在，可直接调用</p></li><li><p>生成器模式（建造者模式）：多个简单的对象构建成一个复杂的对象。</p></li><li><p>原型模式：用于创建重复的对象，同时又能保证性能</p></li></ol><p>行为型模式：行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p><ol><li>策略模式：<em>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</em></li><li>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</li><li>状态模式：对象不同状态之间的切换。</li></ol><h1 id="2022-03-10"><a href="#2022-03-10" class="headerlink" title="2022.03.10"></a>2022.03.10</h1><p>数据结构：</p><ol><li>数组：</li></ol><p>​        查找时间复杂度 O(1)</p><p>​        修改时间复杂度O(n)</p><ol start="2"><li>链表：</li></ol><p>​        查找时间复杂度 O(n)</p><p>​        修改时间复杂度O(1)</p><h1 id="2022-06-07"><a href="#2022-06-07" class="headerlink" title="2022.06.07"></a>2022.06.07</h1><p>找时间整一个批量更新文件的脚本 便于更新测试服和正式服</p><p>温习一下容器相关内容，虽然本地不能部署容器 但是有时间还是可以玩玩的。</p><h1 id="2022-06-10"><a href="#2022-06-10" class="headerlink" title="2022.06.10"></a>2022.06.10</h1><p>linux备份策略：</p><ol><li>完全备份；<ul><li>每次都备份全部内容；</li></ul></li><li>累计增量备份；<ul><li>每次只备份相对比前一次备份增加的内容；</li></ul></li><li>差异增量备份；<ul><li>每次只备份相对比第一次备份增加的内容；</li></ul></li></ol><h1 id="2022-07-20"><a href="#2022-07-20" class="headerlink" title="2022.07.20"></a>2022.07.20</h1><p>go语言高级编程：书籍阅读</p><p>第一章：</p><p>数组字符串和切片：</p><ol><li>数组：</li></ol><p>数组的长度由下标值决定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>                    <span class="hljs-comment">// 定义长度为3的int型数组, 元素全部为0</span><br><span class="hljs-keyword">var</span> b = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;       <span class="hljs-comment">// 定义长度为3的int型数组, 元素为 1, 2, 3</span><br><span class="hljs-keyword">var</span> c = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">1</span>: <span class="hljs-number">2</span>&#125;    <span class="hljs-comment">// 定义长度为3的int型数组, 元素为 0, 2, 3</span><br><span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">// 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCode</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>m := [...]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>m[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">3</span><br>fmt.Println(<span class="hljs-built_in">len</span>(m))<br><br><span class="hljs-comment">// 我们知晓 c 的 ASCII 码是 99，这道题相当于这样</span><br><span class="hljs-comment">/* m := [...]int&#123;</span><br><span class="hljs-comment">97: 1,</span><br><span class="hljs-comment">98: 2,</span><br><span class="hljs-comment">99: 3,</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">m[97] = 3</span><br><span class="hljs-comment">fmt.Println(len(m)) */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>切片：</li></ol><p>使用append 时候尽量避免扩容</p><p>由于<code>append</code>函数返回新的切片，也就是它支持链式操作。我们可以将多个<code>append</code>操作组合起来，实现在切片中间插入元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span><br>a = <span class="hljs-built_in">append</span>(a[:i], <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;x&#125;, a[i:]...)...)     <span class="hljs-comment">// 在第i个位置插入x</span><br>a = <span class="hljs-built_in">append</span>(a[:i], <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, a[i:]...)...) <span class="hljs-comment">// 在第i个位置插入切片</span><br></code></pre></td></tr></table></figure><p>对切面元素进行操作的时候可以使用<code>copy</code>和<code>append</code>组合</p><p>可以用<code>copy</code>和<code>append</code>组合可以避免创建中间的临时切片，同样是完成添加元素的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">0</span>)     <span class="hljs-comment">// 切片扩展1个空间</span><br><span class="hljs-built_in">copy</span>(a[i+<span class="hljs-number">1</span>:], a[i:]) <span class="hljs-comment">// a[i:]向后移动1个位置</span><br>a[i] = x             <span class="hljs-comment">// 设置新添加的元素</span><br></code></pre></td></tr></table></figure><ol start="3"><li>避免切片内存泄漏</li></ol><p>如前面所说，切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。</p><p>例如，<code>FindPhoneNumber</code>函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindPhoneNumber</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    <span class="hljs-keyword">return</span> regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>).Find(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码返回的<code>[]byte</code>指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。</p><p>要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（数据的传值是Go语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindPhoneNumber</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    b = regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>).Find(b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>([]<span class="hljs-type">byte</span>&#123;&#125;, b...)<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的问题，在删除切片元素时可能会遇到。假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []*<span class="hljs-type">int</span>&#123; ... &#125;<br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]    <span class="hljs-comment">// 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍</span><br></code></pre></td></tr></table></figure><p>保险的方式是先将需要自动内存回收的元素设置为<code>nil</code>，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []*<span class="hljs-type">int</span>&#123; ... &#125;<br>a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span> <span class="hljs-comment">// GC回收最后一个元素内存</span><br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]  <span class="hljs-comment">// 从切片删除最后一个元素</span><br></code></pre></td></tr></table></figure><p>当然，如果切片存在的周期很短的话，可以不用刻意处理这个问题。因为如果切片本身已经可以被GC回收的话，切片对应的每个元素自然也就是可以被回收的了。</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
      <tag>设计模式</tag>
      
      <tag>框架</tag>
      
      <tag>更新策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slot</title>
    <link href="/2021/04/02/slot/"/>
    <url>/2021/04/02/slot/</url>
    
    <content type="html"><![CDATA[<h2 id="2021-04-02"><a href="#2021-04-02" class="headerlink" title="2021.04.02"></a>2021.04.02</h2><hr><p>slot设计：</p><p>通信协议设计：</p><p>C====&gt;&gt;S</p><ul><li>开始游戏    需携带参数（压注线，压注数）</li><li>游戏记录    参数（玩家id，可唯一确认玩家信息的标志都可）</li></ul><p>S====&gt;&gt;C</p><ul><li>开始游戏返回    玩家中奖信息，或者转换游戏场景（特殊奖励阶段）</li><li>返回游戏记录列表    </li></ul><p>游戏图标：</p><ul><li><p>bonus 触发独立奖励</p></li><li><p>wild 万能图标</p></li><li><p>east is land 5连线触发独立奖励</p></li><li><p>其他按照连线处理中奖，至少3连线</p></li></ul><p> 所有线条数组<br>0     3     6     9         12<br>1     4     7     10         13<br>2     5     8     11         14</p><p> 所有线条数组（新版本）<br>0     1    2    3    4</p><p>5    6    7    8    9</p><p>10    11    12    13    14</p><h2 id="2021-04-07"><a href="#2021-04-07" class="headerlink" title="2021.04.07"></a>2021.04.07</h2><hr><p>onStart()</p><ul><li>初始化场景数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>炸金花算法</title>
    <link href="/2021/03/16/%E7%82%B8%E9%87%91%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/16/%E7%82%B8%E9%87%91%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2021-03-16"><a href="#2021-03-16" class="headerlink" title="2021.03.16"></a>2021.03.16</h1><p>炸金花<br>牌型大小：    min        max        牌型<br>    豹子        222        AAA        5<br>    顺金        234        AKQ        4<br>    金花        352        AKJ        3<br>    顺子        234        AKQ        2<br>    对子        223        AAK        1<br>    高牌        235        AKJ        0</p><p>牌值大小：<br>    A     ==&gt;    12<br>    K    ==&gt;    11<br>    Q    ==&gt;    10<br>    J    ==&gt;    9<br>    10    ==&gt;    8<br>    9    ==&gt;    7<br>    8    ==&gt;    6<br>    7    ==&gt;    5<br>    6    ==&gt;    4<br>    5    ==&gt;    3<br>    4    ==&gt;    2<br>    3    ==&gt;    1<br>    2    ==&gt;    0</p><p>牌型 牌值 = 牌力</p><p>examples<br>0      5    1280<br>0    A     4096</p><p>1    2    4608<br>1    A     69693</p>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>炸金花</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架通信</title>
    <link href="/2021/03/05/%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/05/%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2021-03-05"><a href="#2021-03-05" class="headerlink" title="2021.03.05"></a>2021.03.05</h1><p>0    1    2    3    4    5    6    7    8    // 1-9筒<br>9    10     11    12    13    14    15    16    17    // 1-9条<br>18    19    20    21    22    23    24    25    26    // 1-9万<br>27    28    29     30    // 东南西北<br>31    32    33    // 中发白</p><p>可增加花牌<br>34    35    36    37 // 春夏秋冬</p><h1 id="2021-03-08"><a href="#2021-03-08" class="headerlink" title="2021.03.08"></a>2021.03.08</h1><p>创建麻将游戏场景的时候，就会初始化麻将牌，ps.buf 并洗牌<br>DrawnCard(card,bool) 发牌<br>cardpool 当前模式整副牌<br>pos 当前状态下的牌索引</p><p>获取万牌数量：100, 200, 800, 900, 800, 0, 0, 0, 0, 1500, 2500, 2000, 800, 400   sum 10000</p><p>随机 0-9999 其中一个数字</p><p>权重. 可通过调整json 配置文件，动态调整麻将发牌类型的概率，而后经过计算各个牌型的分值，计算出该手牌的牌型分数</p><p>根据牌型分数 加之其他策略，决定是否把好牌发给机器人    player1 player2  handcard1 handcard2</p><h1 id="2021-03-09"><a href="#2021-03-09" class="headerlink" title="2021.03.09"></a>2021.03.09</h1><p>发牌逻辑：玩家听牌后摸到的牌直接替换成自己可以胡的牌，通过客户端传的playerop opcode10 来开启功能。</p><p>分析其他玩家操作当前出牌，数据结构使用队列。 依次把 胡 杠 碰 吃 操作写入。</p><p>canHu() 分析玩家能否胡牌</p><p>思路 把当前手牌大于2张的牌，依次看做将牌，带入计算，获取顺子 和刻子 看是否能胡牌    风扑，将扑</p><p>胡牌数据结构图：<br>                        root<br>    1-9筒    1-9万    1-9条    东南西北        中发白        //去除2张将牌<br>1    2    3    4                                        //构建顺牌，添加刻子</p><p>时间复杂度：最坏情况下 14<em>34</em>3 O(n²)<br>空间复杂度：拷贝一份，然后传递指针 O(n)</p><h1 id="2021-03-10"><a href="#2021-03-10" class="headerlink" title="2021.03.10"></a>2021.03.10</h1><p>玩家操作： 思路，直接把玩家摸牌和其他玩家打牌，分开分别处理。就不存在判断供牌玩家，胡牌玩家了。<br>    自身摸牌时操作，由客户端进行处理。<br>    waitdiscard 阶段，接收客户端发送的 出牌 暗杠，补杠，胡，过操作</p><pre><code class="hljs">别人打出的牌进行操作，根据玩家进行压栈操作。依次压入 胡 碰杠 吃waitcpkh 阶段，接收客户端根据服务器返回操作 而发送的 胡，抢杠胡，碰杠，吃，过操作</code></pre><h1 id="2021-03-11"><a href="#2021-03-11" class="headerlink" title="2021.03.11"></a>2021.03.11</h1><p>上午详细研究 吃碰杠胡算法<br>然后研究框架</p><p>胡牌 去除将牌，去除刻子，看剩余手牌是否可以组成顺子<br>碰牌 当前牌数量是否&gt;=2<br>杠牌 当前牌数量是否==3<br>吃牌 枚举所有情况 123 456 789  9种吃牌情况</p><p>1 23<br>12 3<br>123</p><p>789<br>78 9<br>7 89</p><p>123 789<br>456</p><p>1    2    3    4    5    6    7    8    9<br>1    4    3    1    1    1    1    1    1</p><p>3 2</p>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>麻将</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发环境搭建</title>
    <link href="/2021/03/03/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/03/03/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>2021.03.03</p><hr><ol><li><p>安装开发软件</p><ul><li>Mysql、MongoDB  安装MongoDB的时候，不要勾选Compress</li><li>sublimeText3</li></ul> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 安装PrettyJson<br><span class="hljs-regexp">//</span> 按Ctrl+Shift+p打开命令框，搜索PCI，打开package安装框<br><span class="hljs-regexp">//</span> 搜索PrettyJson，点击条目安装<br><span class="hljs-regexp">//</span> Ctrl+Alt+J就可格式化json数据<br></code></pre></td></tr></table></figure><ul><li>vscode  使用GitHub账号同步插件设置</li><li>navicatPremium</li><li>Git</li><li>svn</li><li>go</li><li>python27</li><li>SourceTree</li><li>WinScp</li><li>Typora</li></ul></li><li><p>配置开发环境</p><ul><li>go<br>  配置gopath<br>  配置代理<br>  配置GO111MODULE</li><li>vscode<br>  vscode相关插件安装(chinese,go,svn…)<br>  安装go相关插件<br>  安装svn，并配置svn.path 路径使用\分隔</li></ul></li></ol><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><hr><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker network create --subnet=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.152</span>/<span class="hljs-number">16</span> --gateway <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> mynetwork<br>docker run -itd --name dgserver --mac-address <span class="hljs-number">00</span>-E0-<span class="hljs-number">6B-68</span>-<span class="hljs-number">05</span>-A7  -v  E:/docker_server/server:/root/server --net mynetwork --ip <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.152</span> centos:centos8 /bin/bash<br></code></pre></td></tr></table></figure><p>Docker安装后，默认会创建下面三种网络类型<br>启动 Docker的时候，用 –network 参数，可以指定网络类型</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -itd <span class="hljs-params">--name</span> test1 <span class="hljs-params">--network</span> bridge <span class="hljs-params">--ip</span> 172.17.0.10 centos<span class="hljs-function">:latest</span> <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure><p>bridge：桥接网络<br>默认情况下启动的Docker容器，都是使用 bridge，Docker安装时创建的桥接网络，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker的IP地址就变了</p><p>none：无指定网络<br>使用 –network=none ，docker 容器就不会分配局域网的IP</p><p>host： 主机网络<br>使用 –network=host，此时，Docker 容器的网络会附属在主机上，两者是互通的。<br>例如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。</p><p>创建自定义网络：（设置固定IP）<br>启动Docker容器的时候，使用默认的网络是不支持指派固定IP的，如下</p><p>步骤1: 创建自定义网络</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">docker network ls<br>NETWORK ID     NAME        DRIVER       <span class="hljs-keyword">SCOPE</span><br><span class="hljs-number">9781</span>b1f585ae    bridge       bridge       <span class="hljs-keyword">local</span><br><span class="hljs-number">1252</span>da701e55    host        host        <span class="hljs-keyword">local</span><br><span class="hljs-number">4</span>f11ae9c85de    mynetwork      bridge       <span class="hljs-keyword">local</span><br><span class="hljs-number">237</span>ea3d5cfbf    <span class="hljs-keyword">none</span>        <span class="hljs-keyword">null</span>        <span class="hljs-keyword">local</span><br></code></pre></td></tr></table></figure><p>步骤2: 创建Docker容器</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -itd <span class="hljs-params">--name</span> networkTest1 <span class="hljs-params">--net</span> mynetwork <span class="hljs-params">--ip</span> 172.18.0.2 centos<span class="hljs-function">:latest</span> <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跑得快算法</title>
    <link href="/2021/02/27/%E8%B7%91%E5%BE%97%E5%BF%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/27/%E8%B7%91%E5%BE%97%E5%BF%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2021-02-27"><a href="#2021-02-27" class="headerlink" title="2021.02.27"></a>2021.02.27</h1><p>var CardValueMap = map[int]int{<br>POKER_EMPTY: -1,<br> 2: 0,<br>  3: 1,<br>   4: 2,<br>    5: 3,<br>     6: 4,<br>      7: 5,<br>       8: 6,<br>        9: 7,</p><pre><code class="hljs">10: 8, 11: 9,  12: 10,   0: 11,    1: 12    &#125;</code></pre><p>// 跑得快,底层数据结构<br> 0    1    2    3    4    5    6    7    8    9    10    11    12    //方片<br> 13    14    15    16    17    18    19    20    21    22    23    24    25    //梅花<br> 26    27    28    29    30    31    32    33    34    35    36    37    38    //红桃<br> 39    40    41    42    43    44    45    46    47    48    49    50    51    //黑桃<br> 52    53    //小王,大王</p><p>card % 13 取模计算得出 牌值切片的索引值</p><p>card % 13 + 1 计算得出牌值<br>根据card值区分花色</p><p>使用链表生成树，实现牌型算法：<br>                                    A<br>                                =========<br>                                |        |<br>                                K        K<br>                            =========<br>                            |        |<br>                            Q        Q<br>                        =========<br>                        |        |<br>                        J        J<br>                    =========<br>                    |        |<br>                    10        10        //实现并非使用二叉树</p><pre><code class="hljs">                                                                            root                                            =====================================================================                                             |                                                                    |    ==================================================================================================        =========    ...依次类推    |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        3        4        5        6        7        8        9        10        J        Q        K        A         2        33  --- 22=========    ...依次类推                                                                                    =========    ...依次类推|        |                                                                                                |        |4  ---  2                                                                                                44  --- 22</code></pre><p>=========<br>|        |                                                                                                …依次类推<br>5  —  2</p><p>…依次类推</p><p>构建出牌树：<br>    1.先排除炸弹<br>    2.从最小牌开始 (递增逐个判断)<br>        A 一张<br>            a.A            找到所有单牌<br>            b.ABCDE        使用所有单牌构建顺子 (从最小单张开始 递增逐个判断)<br>            c.AAAB        找到所有的3张，构建三带一 (从最小3张开始 递增逐个判断)<br>            d.AAABBBCD    使用所有的3张构建飞机带单牌 (从最长的开始)</p><pre><code class="hljs">    B 两张        a.AA         找到所有对子        b.AABB        使用所有对子构建顺子        c.AAABB     找到所有的3张，构建三带二        d.AAABBBCCDD使用所有的3张构建飞机带对牌    C 三张        a.AAABB         找到所有的3张，构建三带二        b.AAABBB         使用所有的三张构建飞机        c.AAABBBCCDD    使用所有的3张构建飞机带对牌    D 四张        a.AAAA    找到所有的4张</code></pre><p>超时自动出牌：<br>    AutoShowCard<br>        getAutoShowCard<br>            首出牌：getBestAutoSuggestCards, 首出最长的牌, 剩余3张和下家报单特殊处理<br>            压牌：getAutoSuggestFunc 首先判断炸弹出牌顺序，相同牌型先出，其次拆牌出，其次出炸弹</p><p>计算树的深度，找出最短的子树：<br>    计算树的最小深度<br>    分析所有叶子节点<br>    计算叶子结点到根节点的路径长度，长度等于最小深度 。即是最短的子树。<br>    计算排序中单牌数量最少的链表<br>    链表排序 按照牌型中最大的牌值    </p>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>跑得快</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linuxCmd</title>
    <link href="/2020/11/25/linuxCmd/"/>
    <url>/2020/11/25/linuxCmd/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./game_private_server -Config=./config/game_config_mjjxhzzm_61.cfg &gt;&gt; <span class="hljs-built_in">log</span>/game_private_server_mjjxhzzm_61.<span class="hljs-built_in">log</span> 2&gt;&amp;1 &amp;<br><br><span class="hljs-built_in">nohup</span> ./game_private_server -Config=./config/game_config_mjhnwxd_61.cfg &gt;&gt; <span class="hljs-built_in">log</span>/game_private_server_mjhnwxdd_61.<span class="hljs-built_in">log</span> 2&gt;&amp;1 &amp;<br><br><span class="hljs-built_in">nohup</span> ./game_private_server -Config=./config/game_config_mjhnayhx_88.cfg mjhnayhx_88 &gt;&gt; <span class="hljs-built_in">log</span>/game_private_server_mjhnayhx_88.<span class="hljs-built_in">log</span> 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>redis 添加测试</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">auth</span> qwe123!@<span class="hljs-comment">#</span><br><span class="hljs-literal">select</span> <span class="hljs-number">9</span><br>hset haunters id <span class="hljs-number">1</span>，<br>HEXISTS haunters<br></code></pre></td></tr></table></figure><p>Redis 设置密码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-built_in">set</span> requirepass password<br>auth password<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">get</span> requirepass<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cmd:<br> <span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> requirepass qwe123!@#<br>  auth qwe123!@#<br> <span class="hljs-built_in"> config </span><span class="hljs-built_in">get</span> requirepass<br></code></pre></td></tr></table></figure><p>optional string PassWord = 3;        // 密码</p><p>  ./protoc.exe –go_out=. ./*.proto</p><p>  “notice#body”</p><p>  624691</p><p>– mysql开启事件命令</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%sche%&#x27;</span>;<br><br><span class="hljs-keyword">set</span> global <span class="hljs-comment">event_scheduler =1</span><br></code></pre></td></tr></table></figure><p>天天 userid 406570</p><p>// ssh连接服务器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> ssh root@<span class="hljs-number">39.100.68.248</span><br></code></pre></td></tr></table></figure><p>// 上传文件到服务器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo scp <span class="hljs-regexp">/Users/</span>xinyi-jin<span class="hljs-regexp">/Desktop/</span>test.txt root@<span class="hljs-number">39.100</span>.<span class="hljs-number">68.248</span>:<span class="hljs-regexp">/root/</span>server/<br></code></pre></td></tr></table></figure><p>// 上传文件到服务器，不会影响当前正在运行的程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rsync -av <span class="hljs-regexp">/Users/</span>xinyi-jin<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/jxserver/</span>bin<span class="hljs-regexp">/xiangque/</span>* root@<span class="hljs-number">39.100</span>.<span class="hljs-number">68.248</span>:<span class="hljs-regexp">/root/</span>server<br></code></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">cygwin错误 <br>原因：ssh.exe可能会与git下边的版本冲突<br>解决办法：可使用-e参数指定ssh.exe<br><br>rsync -av -e <span class="hljs-symbol">D:</span>\soft\cwrsync_6.<span class="hljs-number">2.4_</span>x64_free\bin\ssh.exe robot/robot root<span class="hljs-variable">@47</span>.<span class="hljs-number">107.37</span>.<span class="hljs-number">120</span><span class="hljs-symbol">:/root/%</span><span class="hljs-number">1</span>/robot/<br></code></pre></td></tr></table></figure><p>// mac 交叉编译linux</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build gripper.go<br></code></pre></td></tr></table></figure><p>Gitshell中输入如下命令解决：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git config --global core.<span class="hljs-built_in">auto</span>crlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>Go 自动生成测试文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">gotests -<span class="hljs-keyword">only</span> IntToRoman -<span class="hljs-keyword">w</span> intToRoman.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>WinSCP命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./WinSCP.com</span>   进入winscp命令行<br>open sftp:<span class="hljs-string">//root</span>@47.107.37.120 -privatekey=C:\Users\Administrator\<span class="hljs-string">.ssh</span>\id_rsa.ppk   连接远端<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows安装软件</title>
    <link href="/2020/11/25/windows_soft/"/>
    <url>/2020/11/25/windows_soft/</url>
    
    <content type="html"><![CDATA[<h2 id="windows-安装软件列表"><a href="#windows-安装软件列表" class="headerlink" title="windows 安装软件列表"></a>windows 安装软件列表</h2><h3 id="1-视频剪辑类："><a href="#1-视频剪辑类：" class="headerlink" title="1.视频剪辑类："></a>1.视频剪辑类：</h3><ul><li>flash</li><li>格式工厂</li><li>PopPlayer</li></ul><h3 id="2-远程控制："><a href="#2-远程控制：" class="headerlink" title="2.远程控制："></a>2.远程控制：</h3><ul><li>TeamViewer</li><li>向日葵</li></ul><h3 id="3-屏幕保护："><a href="#3-屏幕保护：" class="headerlink" title="3.屏幕保护："></a>3.屏幕保护：</h3><ul><li>护眼宝</li></ul><h3 id="4-驱动系列："><a href="#4-驱动系列：" class="headerlink" title="4.驱动系列："></a>4.驱动系列：</h3><ul><li>MSI官网 Ge72 6QF相关驱动软件</li></ul><h3 id="5-办公系列："><a href="#5-办公系列：" class="headerlink" title="5.办公系列："></a>5.办公系列：</h3><ul><li>WPS Office</li><li>有道词典</li></ul><h3 id="6-翻墙VPN："><a href="#6-翻墙VPN：" class="headerlink" title="6.翻墙VPN："></a>6.翻墙VPN：</h3><ul><li>蓝灯 lantern</li><li>自由门</li></ul><h3 id="7-浏览器"><a href="#7-浏览器" class="headerlink" title="7.浏览器"></a>7.浏览器</h3><ul><li>谷歌浏览器</li><li>油猴相关插件</li></ul><h3 id="8-开发相关"><a href="#8-开发相关" class="headerlink" title="8.开发相关"></a>8.开发相关</h3><ul><li>必备软件</li><li>VSCode</li><li>Git</li><li>MySQL</li><li>MongoDB</li><li>Redis</li><li>SubineText<ul><li>可根据需要选装</li><li>OpenSSH-win64  ssh工具</li><li>运行Game使用Python27,3版本的不支持</li><li>XShell</li><li>Xftp</li><li>winscp</li><li>explore++</li><li>……</li></ul></li></ul><h3 id="9-输入法"><a href="#9-输入法" class="headerlink" title="9.输入法"></a>9.输入法</h3><ul><li>搜狗输入法</li></ul><h3 id="10-聊天交流"><a href="#10-聊天交流" class="headerlink" title="10.聊天交流"></a>10.聊天交流</h3><ul><li>QQ</li><li>微信</li></ul><h3 id="11-文件搜索、编辑、备份、解压工具"><a href="#11-文件搜索、编辑、备份、解压工具" class="headerlink" title="11.文件搜索、编辑、备份、解压工具"></a>11.文件搜索、编辑、备份、解压工具</h3><ul><li>Typora</li><li>Listary</li><li>百度云盘</li><li>winRAR</li></ul><h3 id="12-截图软件"><a href="#12-截图软件" class="headerlink" title="12.截图软件"></a>12.截图软件</h3><ul><li>Snipaste（支持Windows和Mac ，多截屏贴图）</li></ul><h3 id="13-抓包工具"><a href="#13-抓包工具" class="headerlink" title="13.抓包工具"></a>13.抓包工具</h3><ul><li>wires hark 推荐</li><li>burp</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go func</title>
    <link href="/2020/03/01/goFunc/"/>
    <url>/2020/03/01/goFunc/</url>
    
    <content type="html"><![CDATA[<h2 id="2020-03-01"><a href="#2020-03-01" class="headerlink" title="2020.03.01"></a>2020.03.01</h2><p>golang 匿名函数</p><p>​    可赋值给变量，使用变量名调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>f:=<span class="hljs-built_in">func</span>()&#123;<br><br>...<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>​    闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span>&#123;<br><br>...<br><br>&#125;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>​    匿名函数用作回调函数</p><p>​    // 遍历切片的每个元素, 通过给定函数进行元素访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br><br> <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br><br>   f(v)<br><br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  // 使用匿名函数打印切片内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">visit([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> &#123;<br><br>  fmt.Println(v)<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>​    封装匿名函数，实现动态调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> fMap = map<span class="hljs-selector-attr">[string]</span>&#123;<br><br><span class="hljs-string">&quot;temp&quot;</span> : <span class="hljs-built_in">func</span>(<span class="hljs-selector-tag">a</span> int)&#123;<br><br>...<br><br>&#125;<br><br>&#125;<br><br><br><br>f := fMap<span class="hljs-selector-attr">[<span class="hljs-string">&quot;temp&quot;</span>]</span><br><br><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
