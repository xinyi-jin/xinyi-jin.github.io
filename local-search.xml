<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构与算法基础</title>
    <link href="/2022/09/15/2022-09-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/15/2022-09-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h3><ul><li>数组与矩阵</li><li><font color=red>线性表（栈、队列）</font></li><li>广义表</li><li><font color=red>树和二叉树</font></li><li>图</li><li><font color=red>排序与查找</font></li><li><font color=red>算法基础及常见的算法</font></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>一维数组</li><li>二维数组：按行存储，按列存储</li><li>多维数组</li></ul><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><ul><li>选择题，可使用代入法</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>软件设计师【软考】</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统安全分析与设计</title>
    <link href="/2022/09/14/2022-09-14-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/09/14/2022-09-14-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h3><ul><li>保密性：最小授权原则、防暴露、信息加密、物理保密</li><li>完整性：安全协议、校验码、密码校验、数字签名、公证</li><li>可用性：综合保障（IP过滤、业务流控制、路由选择控制、审计跟踪）</li><li>不可抵赖性：数字签名</li></ul><h3 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h3><p>优点：安全，不易破解</p><p>缺点：计算量大，不适合传递大数据，加密速度慢</p><ul><li>RSA:512位（或者1024位）密钥、计算量大、难破解</li><li>ECC：椭圆曲线算法</li><li>Elgamal:</li><li>背包算法、Rabin、D-H</li></ul><h3 id="对称加密技术"><a href="#对称加密技术" class="headerlink" title="对称加密技术"></a>对称加密技术</h3><p>优点：计算量小，速度快</p><p>缺点：不安全</p><ul><li><p>DES：替换+移位、56位密钥、64位数据块、速度快、密钥易产生</p><p>3DES（三重DES）：两个56位的密钥K1/K2</p><p>加密：K1加密-&gt;K2解密-&gt;K1加密</p><p>解密：K1解密-&gt;K2加密-&gt;K1解密</p></li><li><p>AES</p></li><li><p>RC-5</p></li><li><p>IDEA算法</p></li></ul><h3 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h3><ul><li><p>写论文时使用，有论文摘要</p></li><li><p>单向散列（Hash）函数、固定长度的散列值</p></li><li><p>MD5</p></li><li><p>SHA:使用密钥较长，比MD5安全一丢丢</p><p>一般用于校验文件的完整性</p></li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li><p>A发送B</p><p>A的数字签名：A签名（相当于私钥加密）-&gt;B签名验证（相当于使用A的公钥解密）</p><p>结合信息摘要使用，仅签名信息摘要</p></li></ul><h3 id="数字信封与PGP"><a href="#数字信封与PGP" class="headerlink" title="数字信封与PGP"></a>数字信封与PGP</h3><ul><li><p>数字信封：</p><p>发送方将原文用对称密钥加密传输，而将对称密钥用接收方公钥加密发送给对方。</p><p>接收方收到电子信封，用自己的私钥解密信封，去除对称密钥解密得原文。</p></li><li><p>数字证书（类似身份证，唯一标识）：</p><p>为了在非对称加密的时候，获取对方公钥时，防止被他人截获更改公钥数据，导致传递数据不一致</p></li></ul><h3 id="网络安全-各个网络层次的安全保障"><a href="#网络安全-各个网络层次的安全保障" class="headerlink" title="网络安全-各个网络层次的安全保障"></a>网络安全-各个网络层次的安全保障</h3><ul><li>Http(明文传输) Https(密文传输 Http+SSL)</li><li>物理层：隔离、屏蔽</li><li>数据链路层：链路加密、PPTP、L2TP</li><li>网络层：防火墙、IPSec</li><li>传输层：SSL/TLS/SET</li><li>会话层、表示层、应用层：PGP（邮件/文件加密）、Https</li></ul><h3 id="网络安全-网络威胁与攻击（1）"><a href="#网络安全-网络威胁与攻击（1）" class="headerlink" title="网络安全-网络威胁与攻击（1）"></a>网络安全-网络威胁与攻击（1）</h3><ul><li>重放攻击（ARP）</li><li>拒绝服务（DOS）</li><li>窃听：</li><li>业务流分析：长期</li><li>信息泄漏</li><li>破坏完整性</li><li>非授权访问</li></ul><h3 id="网络安全-网络威胁与攻击（2）"><a href="#网络安全-网络威胁与攻击（2）" class="headerlink" title="网络安全-网络威胁与攻击（2）"></a>网络安全-网络威胁与攻击（2）</h3><ul><li>假冒</li><li>旁路控制</li><li>授权侵犯</li><li>特洛伊木马</li><li>陷阱门</li><li>抵赖</li></ul><h3 id="网络安全-防火墙"><a href="#网络安全-防火墙" class="headerlink" title="网络安全-防火墙"></a>网络安全-防火墙</h3><ul><li>网络级：包过滤、状态校验</li><li>应用级：双穴主机、屏蔽主机、屏蔽子网</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件设计师【软考】</tag>
      
      <tag>系统安全分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/09/14/2022-09-14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/09/14/2022-09-14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="IP地址与子网划分"><a href="#IP地址与子网划分" class="headerlink" title="IP地址与子网划分"></a>IP地址与子网划分</h3><ol><li>A类 B类 C类 D类</li></ol><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">0000000</span> <span class="hljs-number">00000000</span><br><span class="hljs-number">255.255</span>.<span class="hljs-number">255.255</span><br><span class="hljs-symbol">11111111 </span><span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span><br></code></pre></td></tr></table></figure><p>A类 首位标志位    0-127<br>B类 前两位标志位    127-191<br>C类 前三位标志位    192-223<br>D类 前四位标志位    224-239</p><ol start="2"><li><p>子网划分</p><ul><li>子网掩码</li><li>将一个网络划分成多个子网</li></ul></li></ol><p>IP地址 ：：={&lt;网络前缀&gt;,&lt;主机&gt;}<br>127.14.21.0/20</p><h3 id="特殊含义的IP地址"><a href="#特殊含义的IP地址" class="headerlink" title="特殊含义的IP地址"></a>特殊含义的IP地址</h3><ul><li><p>127网段（回播地址）</p></li><li><p>网络号全0地址（当前子网中的地址）</p></li><li><p>全1地址（本地子网的广播）</p></li><li><p>主机号全1地址（特定子网的广播）</p></li><li><p>10.0.0.1至10.255.255.254</p><p>172.16.0.1至172.31.255.254</p><p>192.168.0.1至192.168.255.254（局域网IP）</p></li><li><p>169.254.0.0（保留地址，用于DHCP失效 win）</p></li><li><p>0.0.0.0（保留地址，用于DHCP失效 linux）</p></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>为了解决IPv4地址不足问题</p><ol><li>单播地址</li><li>任播地址</li><li>组播地址</li></ol><h3 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h3><ol><li>无线局域网（WLAN,802.11,Wi-Fi）</li><li>无线城域网</li><li>无线广域网（WWAN 3G/4G/5G）</li><li>无线个人网（WPAN 蓝牙）</li></ol><h3 id="网络接入技术"><a href="#网络接入技术" class="headerlink" title="网络接入技术"></a>网络接入技术</h3><ol><li><p>有线接入（PSTN,DDN,ISDN,ADSL,HFC）</p></li><li><p>无线接入（WiFi，蓝牙，红外，WAPI）</p></li><li><p>3G/4G/5G（WCDMA,CDMA2000,TD-SCDMA中国移动）</p><p>LTE 4G 分为TDD时分，FDD频分</p></li></ol><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><table><thead><tr><th align="center"><a></th><th align="center">锚点</th></tr></thead><tbody><tr><td align="center"><b></td><td align="center">粗体</td></tr><tr><td align="center"><body></td><td align="center">主体</td></tr><tr><td align="center"><button></td><td align="center">按钮</td></tr><tr><td align="center"><center></td><td align="center">居中</td></tr><tr><td align="center"><col></td><td align="center">定义表格一个或多个列属性</td></tr><tr><td align="center"><font></td><td align="center">字体属性</td></tr><tr><td align="center"><form></td><td align="center">表单</td></tr><tr><td align="center"><frame></td><td align="center">框架窗口</td></tr><tr><td align="center"><h1></td><td align="center">一级标题</td></tr><tr><td align="center"><hr></td><td align="center">水平线</td></tr><tr><td align="center"><html></td><td align="center">html文档</td></tr><tr><td align="center"><img></td><td align="center">图片</td></tr><tr><td align="center"><p></td><td align="center">段落</td></tr><tr><td align="center"><script></td><td align="center">脚本</td></tr><tr><td align="center"><strong></td><td align="center">强调文本</td></tr><tr><td align="center"><table></td><td align="center">表格</td></tr><tr><td align="center"><td></td><td align="center">表格单元</td></tr><tr><td align="center"><tr></td><td align="center">表格行</td></tr><tr><td align="center"><title></td><td align="center">标题</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件设计师【软考】</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/13/hello-world/"/>
    <url>/2022/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git ssh连接</title>
    <link href="/2022/09/13/github-ssh/"/>
    <url>/2022/09/13/github-ssh/</url>
    
    <content type="html"><![CDATA[<p>github ssh</p><ol><li>// 配置git用户</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;iezhuhe@163.com&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xinyi-jin&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>// genssh</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;iezhuhe@163.com&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>// verssh</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go源码阅读</title>
    <link href="/2022/09/13/Go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/09/13/Go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>Go 源码阅读<br>fmt：</p><p>rand:</p><p>​    Top Function level 简单思路阅读 未深究数据 只阅读了核心思想</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2022/08/23/test/"/>
    <url>/2022/08/23/test/</url>
    
    <content type="html"><![CDATA[<p>这里是公众号「宫水三叶的刷题日记」的 Github 仓库 🎉🎉</p><p><img src="https://github-readme-stats.vercel.app/api?username=SharingSource&show_icons=true&theme=default" alt="Anurag&#39;s GitHub stats"></p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学习内容</title>
    <link href="/2022/08/23/docker/"/>
    <url>/2022/08/23/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>docker容器不保持任何数据<br>重要数据请使用外部卷存储（数据持久化）<br>容器可以挂载真实机目录或共享存储为卷</p><h3 id="主机卷映射："><a href="#主机卷映射：" class="headerlink" title="主机卷映射："></a>主机卷映射：</h3><ul><li>宿主机到docker容器映射：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">docker run -it -v /<span class="hljs-keyword">var</span>/data:/abc myos<br></code></pre></td></tr></table></figure><ul><li>自定义容器内部网络</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create <span class="hljs-attribute">--subnet</span>=172.18.0.0/16 mynet<br></code></pre></td></tr></table></figure><ul><li>使用自定义网络运行容器,再次重启时就不会按照启动顺序分配172.17.0.1网段的ip地址了</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -itd <span class="hljs-params">--name</span> vm  <span class="hljs-params">--net</span> bind <span class="hljs-params">--ip</span> 172.18.0.103 centos <span class="hljs-string">/sbin/init</span><br></code></pre></td></tr></table></figure><p>原文地址：<a href="https://cloud.tencent.com/developer/article/1966389">https://cloud.tencent.com/developer/article/1966389</a></p><h2 id="修复-“Error-Failed-to-download-metadata-for-repo-appstream”-–-CentOS-8系统错误"><a href="#修复-“Error-Failed-to-download-metadata-for-repo-appstream”-–-CentOS-8系统错误" class="headerlink" title="修复: “Error: Failed to download metadata for repo appstream” – CentOS 8系统错误"></a>修复: “Error: Failed to download metadata for repo appstream” – CentOS 8系统错误</h2><p><strong>解决方案：迁移到 CentOS Stream 8 或替代发行版</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">dnf</span> <span class="hljs-built_in">--disablerepo</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">--enablerepo=extras</span> <span class="hljs-string">swap</span> <span class="hljs-string">centos-linux-repos</span> <span class="hljs-string">centos-stream-repos</span> <br><span class="hljs-string">dnf</span> <span class="hljs-string">distro-sync</span><br></code></pre></td></tr></table></figure><p>docker 桥接方式映射宿主机IP端口，并挂载宿主机文件卷，初始化容器环境，赋予最高操作权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -itd --name goservice -p <span class="hljs-number">41002</span>:<span class="hljs-number">31002</span> -p <span class="hljs-number">10989</span>:<span class="hljs-number">9898</span> --privileged -v <span class="hljs-regexp">/root/</span>hn_match_debug<span class="hljs-regexp">/:/</span>root<span class="hljs-regexp">/hn_match_debug/</span> centos <span class="hljs-regexp">/sbin/i</span>nit<br></code></pre></td></tr></table></figure><p>注册mongod服务</p><p>mogod.conf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># ip</span><br><br><span class="hljs-attr">bind_ip</span>=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><br><span class="hljs-comment"># mongodb port number</span><br><br><span class="hljs-attr">port</span>=<span class="hljs-number">27017</span><br><br><span class="hljs-comment"># mongodb data file path</span><br><br><span class="hljs-attr">dbpath</span>=/var/lib/mongo<br><br><span class="hljs-comment"># mongodb log file path</span><br><br><span class="hljs-attr">logpath</span>=/var/log/mongodb/mongod.log<br><br><span class="hljs-comment"># mongodb automatically append log files</span><br><br><span class="hljs-attr">logappend</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>mongod</p><p>进入 /etc/init.d/ 目录<br><code># cd /etc/init.d/</code><br>创建并编辑mongodb文件<br><code># vim mongodb</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#chkconfig:345 61 61</span><br><span class="hljs-comment">#description:mongod</span><br><br><span class="hljs-comment"># mongoDB shell version v5.0.9</span><br><br><span class="hljs-comment"># connecting to: mongodb://0.0.0.0:27017</span><br><br><span class="hljs-comment"># MongoDB server version: 5.0.9</span><br><br>MONGO_PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mongodb5/</span>bin/mongod<br>MONGO_PID=`ps -ef|grep <span class="hljs-string">&#x27;mongod&#x27;</span> | grep -v grep|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br>test -x <span class="hljs-variable">$MONGO_PATH</span> || <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br><br>case <span class="hljs-string">&quot;$1&quot;</span> <span class="hljs-keyword">in</span><br>  start)<br>     ulimit -n <span class="hljs-number">2000</span><br>     echo <span class="hljs-string">&quot;starting mongod server&quot;</span><br>     <span class="hljs-variable">$MONGO_PATH</span> --fork --quiet -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mongodb5/m</span>ongod.conf<br>     echo <span class="hljs-string">&quot;started mongod server&quot;</span><br>     ;;<br>  stop)<br>     echo <span class="hljs-string">&quot;stopping mongod server&quot;</span><br>     <span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;$MONGO_PID&quot;</span> ]; then<br>        kill -<span class="hljs-number">15</span> <span class="hljs-variable">$MONGO_PID</span><br>     fi<br>        echo <span class="hljs-string">&quot;stopped mongod server&quot;</span><br>     ;;<br>  status)<br>     ;;<br>  *)<br>     echo <span class="hljs-string">&quot;usage: mongod &#123;start|stop|status&#125;&quot;</span><br>     <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>esac<br><br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述文件配置完成后，执行一下几条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x /etc/init.d/mongod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">chkconfig --add mongod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">chkconfig mongod on</span><br></code></pre></td></tr></table></figure><p>启动时去除ip绑定</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mongod</span> --bind_ip <span class="hljs-number">0.0.0.0</span><br></code></pre></td></tr></table></figure><h2 id="一：通过修改配置文件修改docker容器端口映射"><a href="#一：通过修改配置文件修改docker容器端口映射" class="headerlink" title="一：通过修改配置文件修改docker容器端口映射"></a>一：通过修改配置文件修改docker容器端口映射</h2><p>1.使用<strong>docker ps -a</strong>命令找到要修改容器的<strong>CONTAINER ID</strong></p><p>2.运行以下命令，进入该容器目录</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">docker inspect【CONTAINER ID】| grep Id<br>cd /var/lib/docker/containers<br></code></pre></td></tr></table></figure><p>2.停止容器</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker stop [容器id]<br></code></pre></td></tr></table></figure><p>3.停止主机docker服务</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">systemctl stop docker<br></code></pre></td></tr></table></figure><p>4.进入2得到的文件夹内，修改hostconfig.json 和 config.v2.json</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">vi hostconfig.json<br><br>比如新增一个 80 端口，在PortBindings下边添加以下内容，端口配置之间用英文字符逗号隔开<br><br>&quot;80/tcp&quot;: [ <br>&#123;<br> &quot;HostIp&quot;: &quot;0.0.0.0&quot;,<br> &quot;HostPort&quot;: &quot;80&quot;<br> &#125;<br>]<br>接着修改vi config.v2.json, 找到ExposedPorts和Ports  仿照之前内容添加端口映射<br>&quot;ExposedPorts&quot;:  &#123;<br>    &quot;2000/tcp&quot;:   &#123;&#125;<br>&#125;,<br><br>&quot;Ports&quot;:&#123;<br>   &quot;2000/tcp&quot;:[<br>        &#123;<br>         &quot;HostIp&quot;: &quot;0.0.0.0&quot;,<br>         &quot;HostPort&quot;:  &quot;2000&quot;<br>         &#125;<br>]<br>&#125;,<br></code></pre></td></tr></table></figure><p>5.保存之后重启docker服务和容器</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">systemctl start docker<br>docker start [docker id]<br></code></pre></td></tr></table></figure><h2 id="二：把运行中的容器生成新的镜像，再新建容器"><a href="#二：把运行中的容器生成新的镜像，再新建容器" class="headerlink" title="二：把运行中的容器生成新的镜像，再新建容器"></a>二：把运行中的容器生成新的镜像，再新建容器</h2><p>1.提交一个运行中的容器为镜像</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker commit [containerid] [new_imagename]<br></code></pre></td></tr></table></figure><p>2.运行新建的镜像并添加端口映射</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker run -d -p 8000:80  [imagename] /bin/sh<br></code></pre></td></tr></table></figure><h2 id="三：修改主机iptables端口映射"><a href="#三：修改主机iptables端口映射" class="headerlink" title="三：修改主机iptables端口映射"></a>三：修改主机iptables端口映射</h2><blockquote><p>docker的端口映射并不是在docker技术中实现的，而是通过宿主机的iptables来实现。通过控制网桥来做端口映射，类似路由器中设置路由端口映射。</p></blockquote><p>如果我们有一个容器的8000端口映射到主机的9000端口，先查看iptabes设置了什么规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -vnL<br></code></pre></td></tr></table></figure><p>结果中有一条：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Chain DOCKER (2 references)<br>pkts bytes target prot opt in     out     source        destination         <br> 98  5872 RETURN  all  --  docker0 *     0.0.0.0/0     0.0.0.0/0           <br>237 14316 DNAT    tcp  --  !docker0 *    0.0.0.0/0    0.0.0.0/0    tcp dpt:9000 to:172.17.0.3:8000<br></code></pre></td></tr></table></figure><p>我们可以看到docker创建了一个名为DOKCER的自定义的链条Chain。而我开放8000端口的容器的ip是172.17.0.3。</p><p>也可以通过inspect命令查看容器ip</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker inspect [containerId] |grep IPAddress<br></code></pre></td></tr></table></figure><p>我们想再增加一个端口映射，比如<code>8081-&gt;81</code>，就在这个链条是再加一条规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -A  DOCKER -p tcp --dport 8081 -j DNAT --to-destination 172.17.0.3:81<br></code></pre></td></tr></table></figure><p>加错了或者想修改：先显示行号查看</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -vnL DOCKER --line-number<br></code></pre></td></tr></table></figure><p>删除规则3</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo iptables -t nat -D DOCKER 3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件整理</title>
    <link href="/2022/03/27/%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <url>/2022/03/27/%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="文件整理"><a href="#文件整理" class="headerlink" title="文件整理"></a>文件整理</h1><h2 id="2022-03-27"><a href="#2022-03-27" class="headerlink" title="2022.03.27"></a>2022.03.27</h2><hr><ol><li>软件安装包</li><li>文档记录</li><li>源码文件</li><li>资源列表</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK的安装与环境配置</title>
    <link href="/2022/02/27/JDK%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/02/27/JDK%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<ul><li>下载JDK安装包<br>首先到Oracle官网下载，链接: <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li></ul><p>需要勾选同意，然后选择自己电脑系统的版本下载。<br>ps:右键我的电脑，属性，查看系统类型。x64是64位，x86是32位。</p><p>下载完成后，双击下载的安装包，采用傻瓜式安装，一路NEXT即可。<br>ps：注意安装路径可以设置在除C盘外的其他盘，例如：D:\Java\jdk-8u181-windows-x64<br>另外，安装路径不要使用中文命名，否则会发生未知错误（第一次装的时候就被坑死了）</p><ul><li>配置JDK的环境变量<br>右键，我的电脑，属性，高级系统设置，高级，环境变量</li></ul><p>找到系统变量中的path，点击编辑，在最前边添加自己的JDK路径信息，然后点击确定。<br>ps：路径信息到bin文件夹下就可以，因为bin文件夹存放的是java的.exe命令，路径末尾不要忘记添加“;”</p><p>然后就可以windows键+R，运行cmd，进入DOS命令行。<br>执行java -version命令，如下图，就表示java环境变量配置成功了。</p><p>ps:新配置好的环境变量，必须重新打开DOS窗口才能正常运行，java -version中，java后边需要留有一个空格</p><p>jdk重装时候遇到的坑0.0，没卸载 干净，这位大哥的博客有解决方案<br><a href="https://blog.csdn.net/ldld1717/article/details/52144760">https://blog.csdn.net/ldld1717/article/details/52144760</a></p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学习内容</title>
    <link href="/2021/10/12/%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/"/>
    <url>/2021/10/12/%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>需要学习的地方：<br>老系统 网关服务与多个服务器之间的调度 gate center login game</p><p>中心服务 拥有网关服务 登陆服务 游戏服务 连接 可以暂时理解为 中心化部署的分布式服务 可动态添加网关服务 以及各个网关主机服务所拥有的 登陆和游戏服务器</p><p>gate 连接 中心服务<br>db 注册rpc<br>center 中心服务 启动rpc服务 http服务 开启其他服务注册监听<br>login 初始化nats 注册到center </p><h1 id="2021-10-12"><a href="#2021-10-12" class="headerlink" title="2021.10.12"></a>2021.10.12</h1><p>开始首局游戏的时候,预留客户端加载资源时间 6s</p><p>引用外部包的时候时候可以更改别人包中代码，只要本地一直有修改过的版本即可，否则拉取的是外部包最新代码，没有自己修改过的版本内容。</p><p>nats相关文档</p><p>mysql 57与8.0版本差异<br>速度 默认字符集格式</p><p>什么算作代码整洁，代码整洁与性能优先考虑点 可阅读代码整洁之道 寻求答案</p><p>为什么系统中同时存在nsq和nats的使用 (nats不支持持久化)</p><p>有时间可以阅读的源码库：<br>cache2go  临时内存缓冲使用<br>gob    rpc数据传输封装</p><p>Go源码 尽快找时间阅读</p><p>archive<br>bufio<br>bulitin<br>bytes<br>cmd<br>compress<br>container<br>context<br>crypto<br>database<br>debug<br>encoding<br>errors<br>expvar<br>flag<br>fmt<br>go<br>hash<br>html<br>image<br>index<br>internal<br>io<br>log<br>math<br>mime<br>net<br>os<br>path<br>plugin<br>reflect<br>regexp<br>runtime<br>sort<br>strconv<br>strings<br>sync<br>syscall<br>testdata<br>testing<br>text<br>time<br>unicode<br>unsafe<br>vendor</p><h1 id="2021-11-23"><a href="#2021-11-23" class="headerlink" title="2021.11.23"></a>2021.11.23</h1><p>数据结构：</p><ul><li>数组  <a href="https://en.wikipedia.org/wiki/Array_data_structure">https://en.wikipedia.org/wiki/Array_data_structure</a></li><li>树 <a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">https://en.wikipedia.org/wiki/Tree_%28data_structure%29</a></li><li>栈 <a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29</a></li><li>队列 <a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29</a></li><li>图 <a href="https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29</a></li><li>哈希表 <a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a></li><li>链表 <a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a></li><li>堆 <a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29">https://en.wikipedia.org/wiki/Heap_%28data_structure%29</a></li></ul><p>算法：</p><ol><li></li></ol><p>面试题相关问题</p><p>1、golang 中 make 和 new 的区别？（基本必问）</p><p>​    make 用于slice map channel 类型的创建以及初始化，返回的是对应类型</p><p>​    new 用于分配内存空间，返回对应类型的内存指针地址</p><p>2、数组和切片的区别 （基本必问）</p><p>​    数组是固定长度的，值类型</p><p>​    切片是可变长度的，引用类型</p><p>3、for range 的时候它的地址会发生变化么？</p><p>​    会，for range 的时候操作的是拷贝的数据</p><p>​    for range 对map类型遍历时候，改变map中键值的话，会影响到输出结果，可能输出改变后的值，也可能不输出或少输出</p><p>4、go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</p><p>​    a.多个defer会倒叙返回，相当于压栈 弹栈操作；</p><h3 id="坑1：defer在匿名返回值和命名返回值函数中的不同表现"><a href="#坑1：defer在匿名返回值和命名返回值函数中的不同表现" class="headerlink" title="坑1：defer在匿名返回值和命名返回值函数中的不同表现"></a>坑1：defer在匿名返回值和命名返回值函数中的不同表现</h3><p>要搞清这个问题首先需要了解defer的执行逻辑，文档中说defer语句在方法返回“时”触发，也就是说return和defer是“同时”执行的。以匿名返回值方法举例，过程如下。</p><ul><li>将result赋值给返回值（可以理解成Go自动创建了一个返回值retValue，相当于执行retValue = result）</li><li>然后检查是否有defer，如果有则执行</li><li>返回刚才创建的返回值（retValue）</li></ul><p>在这种情况下，defer中的修改是对result执行的，而不是retValue，所以defer返回的依然是retValue。在命名返回值方法中，由于返回值在方法定义时已经被定义，所以没有创建retValue的过程，result就是retValue，defer对于result的修改也会被直接返回。</p><h3 id="坑2：在for循环中使用defer可能导致的性能问题"><a href="#坑2：在for循环中使用defer可能导致的性能问题" class="headerlink" title="坑2：在for循环中使用defer可能导致的性能问题"></a>坑2：在for循环中使用defer可能导致的性能问题</h3><p>defer在紧邻创建资源的语句后生命力，看上去逻辑没有什么问题。但是和直接调用相比，defer的执行存在着额外的开销，例如defer会对其后需要的参数进行内存拷贝，还需要对defer结构进行压栈出栈操作。所以在循环中定义defer可能导致大量的资源开销，在本例中，可以将f.Close()语句前的defer去掉，来减少大量defer导致的额外资源消耗。</p><h3 id="坑3：判断执行没有err之后，再defer释放资源"><a href="#坑3：判断执行没有err之后，再defer释放资源" class="headerlink" title="坑3：判断执行没有err之后，再defer释放资源"></a>坑3：判断执行没有err之后，再defer释放资源</h3><p>一些获取资源的操作可能会返回err参数，我们可以选择忽略返回的err参数，但是如果要使用defer进行延迟释放的的话，需要在使用defer之前先判断是否存在err，如果资源没有获取成功，即没有必要也不应该再对资源执行释放操作。如果不判断获取资源是否成功就执行释放操作的话，还有可能导致释放方法执行错误。</p><h3 id="坑4：调用os-Exit时defer不会被执行"><a href="#坑4：调用os-Exit时defer不会被执行" class="headerlink" title="坑4：调用os.Exit时defer不会被执行"></a>坑4：调用os.Exit时defer不会被执行</h3><p>当发生panic时，所在goroutine的所有defer会被执行，但是当调用os.Exit()方法退出程序时，defer并不会被执行。</p><p>5、 uint 类型溢出</p><p>​    数值类型溢出的时候，会重置为0</p><p>6、介绍 rune 类型</p><p>​    rune 相当于int32，特殊的字节类型  可以表示中文字符</p><p>​    uint8 表示一般字符</p><h1 id="2021-11-23-1"><a href="#2021-11-23-1" class="headerlink" title="2021.11.23"></a>2021.11.23</h1><p>设计模式：</p><p>开闭原则：对拓展开放，对修改关闭。</p><p>里氏换元原则：父类可调用的方法，子类也可调用。继承</p><p>OOP 四大特性：封装、继承、多态、抽象</p><p>创建型模式：创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p><ol><li><p>工厂模式：对象的创建和使用分离。</p></li><li><p>抽象工厂模式：通过传递参数获取实体类的对象。意图提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p>单例模式：实例只创建一次，常存在，可直接调用</p></li><li><p>生成器模式（建造者模式）：多个简单的对象构建成一个复杂的对象。</p></li><li><p>原型模式：用于创建重复的对象，同时又能保证性能</p></li></ol><p>行为型模式：行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p><ol><li>策略模式：<em>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</em></li><li>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</li><li>状态模式：对象不同状态之间的切换。</li></ol><h1 id="2022-03-10"><a href="#2022-03-10" class="headerlink" title="2022.03.10"></a>2022.03.10</h1><p>数据结构：</p><ol><li>数组：</li></ol><p>​        查找时间复杂度 O(1)</p><p>​        修改时间复杂度O(n)</p><ol start="2"><li>链表：</li></ol><p>​        查找时间复杂度 O(n)</p><p>​        修改时间复杂度O(1)</p><h1 id="2022-06-07"><a href="#2022-06-07" class="headerlink" title="2022.06.07"></a>2022.06.07</h1><p>找时间整一个批量更新文件的脚本 便于更新测试服和正式服</p><p>温习一下容器相关内容，虽然本地不能部署容器 但是有时间还是可以玩玩的。</p><h1 id="2022-06-10"><a href="#2022-06-10" class="headerlink" title="2022.06.10"></a>2022.06.10</h1><p>linux备份策略：</p><ol><li>完全备份；<ul><li>每次都备份全部内容；</li></ul></li><li>累计增量备份；<ul><li>每次只备份相对比前一次备份增加的内容；</li></ul></li><li>差异增量备份；<ul><li>每次只备份相对比第一次备份增加的内容；</li></ul></li></ol><h1 id="2022-07-20"><a href="#2022-07-20" class="headerlink" title="2022.07.20"></a>2022.07.20</h1><p>go语言高级编程：书籍阅读</p><p>第一章：</p><p>数组字符串和切片：</p><ol><li>数组：</li></ol><p>数组的长度由下标值决定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>                    <span class="hljs-comment">// 定义长度为3的int型数组, 元素全部为0</span><br><span class="hljs-keyword">var</span> b = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;       <span class="hljs-comment">// 定义长度为3的int型数组, 元素为 1, 2, 3</span><br><span class="hljs-keyword">var</span> c = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">1</span>: <span class="hljs-number">2</span>&#125;    <span class="hljs-comment">// 定义长度为3的int型数组, 元素为 0, 2, 3</span><br><span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">// 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCode</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>m := [...]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>m[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">3</span><br>fmt.Println(<span class="hljs-built_in">len</span>(m))<br><br><span class="hljs-comment">// 我们知晓 c 的 ASCII 码是 99，这道题相当于这样</span><br><span class="hljs-comment">/* m := [...]int&#123;</span><br><span class="hljs-comment">97: 1,</span><br><span class="hljs-comment">98: 2,</span><br><span class="hljs-comment">99: 3,</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">m[97] = 3</span><br><span class="hljs-comment">fmt.Println(len(m)) */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>切片：</li></ol><p>使用append 时候尽量避免扩容</p><p>由于<code>append</code>函数返回新的切片，也就是它支持链式操作。我们可以将多个<code>append</code>操作组合起来，实现在切片中间插入元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span><br>a = <span class="hljs-built_in">append</span>(a[:i], <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;x&#125;, a[i:]...)...)     <span class="hljs-comment">// 在第i个位置插入x</span><br>a = <span class="hljs-built_in">append</span>(a[:i], <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, a[i:]...)...) <span class="hljs-comment">// 在第i个位置插入切片</span><br></code></pre></td></tr></table></figure><p>对切面元素进行操作的时候可以使用<code>copy</code>和<code>append</code>组合</p><p>可以用<code>copy</code>和<code>append</code>组合可以避免创建中间的临时切片，同样是完成添加元素的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">0</span>)     <span class="hljs-comment">// 切片扩展1个空间</span><br><span class="hljs-built_in">copy</span>(a[i+<span class="hljs-number">1</span>:], a[i:]) <span class="hljs-comment">// a[i:]向后移动1个位置</span><br>a[i] = x             <span class="hljs-comment">// 设置新添加的元素</span><br></code></pre></td></tr></table></figure><ol start="3"><li>避免切片内存泄漏</li></ol><p>如前面所说，切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。</p><p>例如，<code>FindPhoneNumber</code>函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindPhoneNumber</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    <span class="hljs-keyword">return</span> regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>).Find(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码返回的<code>[]byte</code>指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。</p><p>要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（数据的传值是Go语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindPhoneNumber</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    b = regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>).Find(b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>([]<span class="hljs-type">byte</span>&#123;&#125;, b...)<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的问题，在删除切片元素时可能会遇到。假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []*<span class="hljs-type">int</span>&#123; ... &#125;<br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]    <span class="hljs-comment">// 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍</span><br></code></pre></td></tr></table></figure><p>保险的方式是先将需要自动内存回收的元素设置为<code>nil</code>，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []*<span class="hljs-type">int</span>&#123; ... &#125;<br>a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span> <span class="hljs-comment">// GC回收最后一个元素内存</span><br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]  <span class="hljs-comment">// 从切片删除最后一个元素</span><br></code></pre></td></tr></table></figure><p>当然，如果切片存在的周期很短的话，可以不用刻意处理这个问题。因为如果切片本身已经可以被GC回收的话，切片对应的每个元素自然也就是可以被回收的了。</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
      <tag>设计模式</tag>
      
      <tag>框架</tag>
      
      <tag>更新策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slot</title>
    <link href="/2021/04/02/slot/"/>
    <url>/2021/04/02/slot/</url>
    
    <content type="html"><![CDATA[<h2 id="2021-04-02"><a href="#2021-04-02" class="headerlink" title="2021.04.02"></a>2021.04.02</h2><hr><p>slot设计：</p><p>通信协议设计：</p><p>C====&gt;&gt;S</p><ul><li>开始游戏    需携带参数（压注线，压注数）</li><li>游戏记录    参数（玩家id，可唯一确认玩家信息的标志都可）</li></ul><p>S====&gt;&gt;C</p><ul><li>开始游戏返回    玩家中奖信息，或者转换游戏场景（特殊奖励阶段）</li><li>返回游戏记录列表    </li></ul><p>游戏图标：</p><ul><li><p>bonus 触发独立奖励</p></li><li><p>wild 万能图标</p></li><li><p>east is land 5连线触发独立奖励</p></li><li><p>其他按照连线处理中奖，至少3连线</p></li></ul><p> 所有线条数组<br>0     3     6     9         12<br>1     4     7     10         13<br>2     5     8     11         14</p><p> 所有线条数组（新版本）<br>0     1    2    3    4</p><p>5    6    7    8    9</p><p>10    11    12    13    14</p><h2 id="2021-04-07"><a href="#2021-04-07" class="headerlink" title="2021.04.07"></a>2021.04.07</h2><hr><p>onStart()</p><ul><li>初始化场景数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>炸金花算法</title>
    <link href="/2021/03/16/%E7%82%B8%E9%87%91%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/16/%E7%82%B8%E9%87%91%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2021-03-16"><a href="#2021-03-16" class="headerlink" title="2021.03.16"></a>2021.03.16</h1><p>炸金花<br>牌型大小：    min        max        牌型<br>    豹子        222        AAA        5<br>    顺金        234        AKQ        4<br>    金花        352        AKJ        3<br>    顺子        234        AKQ        2<br>    对子        223        AAK        1<br>    高牌        235        AKJ        0</p><p>牌值大小：<br>    A     ==&gt;    12<br>    K    ==&gt;    11<br>    Q    ==&gt;    10<br>    J    ==&gt;    9<br>    10    ==&gt;    8<br>    9    ==&gt;    7<br>    8    ==&gt;    6<br>    7    ==&gt;    5<br>    6    ==&gt;    4<br>    5    ==&gt;    3<br>    4    ==&gt;    2<br>    3    ==&gt;    1<br>    2    ==&gt;    0</p><p>牌型 牌值 = 牌力</p><p>examples<br>0      5    1280<br>0    A     4096</p><p>1    2    4608<br>1    A     69693</p>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>炸金花</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架通信</title>
    <link href="/2021/03/05/%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/05/%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2021-03-05"><a href="#2021-03-05" class="headerlink" title="2021.03.05"></a>2021.03.05</h1><p>0    1    2    3    4    5    6    7    8    // 1-9筒<br>9    10     11    12    13    14    15    16    17    // 1-9条<br>18    19    20    21    22    23    24    25    26    // 1-9万<br>27    28    29     30    // 东南西北<br>31    32    33    // 中发白</p><p>可增加花牌<br>34    35    36    37 // 春夏秋冬</p><h1 id="2021-03-08"><a href="#2021-03-08" class="headerlink" title="2021.03.08"></a>2021.03.08</h1><p>创建麻将游戏场景的时候，就会初始化麻将牌，ps.buf 并洗牌<br>DrawnCard(card,bool) 发牌<br>cardpool 当前模式整副牌<br>pos 当前状态下的牌索引</p><p>获取万牌数量：100, 200, 800, 900, 800, 0, 0, 0, 0, 1500, 2500, 2000, 800, 400   sum 10000</p><p>随机 0-9999 其中一个数字</p><p>权重. 可通过调整json 配置文件，动态调整麻将发牌类型的概率，而后经过计算各个牌型的分值，计算出该手牌的牌型分数</p><p>根据牌型分数 加之其他策略，决定是否把好牌发给机器人    player1 player2  handcard1 handcard2</p><h1 id="2021-03-09"><a href="#2021-03-09" class="headerlink" title="2021.03.09"></a>2021.03.09</h1><p>发牌逻辑：玩家听牌后摸到的牌直接替换成自己可以胡的牌，通过客户端传的playerop opcode10 来开启功能。</p><p>分析其他玩家操作当前出牌，数据结构使用队列。 依次把 胡 杠 碰 吃 操作写入。</p><p>canHu() 分析玩家能否胡牌</p><p>思路 把当前手牌大于2张的牌，依次看做将牌，带入计算，获取顺子 和刻子 看是否能胡牌    风扑，将扑</p><p>胡牌数据结构图：<br>                        root<br>    1-9筒    1-9万    1-9条    东南西北        中发白        //去除2张将牌<br>1    2    3    4                                        //构建顺牌，添加刻子</p><p>时间复杂度：最坏情况下 14<em>34</em>3 O(n²)<br>空间复杂度：拷贝一份，然后传递指针 O(n)</p><h1 id="2021-03-10"><a href="#2021-03-10" class="headerlink" title="2021.03.10"></a>2021.03.10</h1><p>玩家操作： 思路，直接把玩家摸牌和其他玩家打牌，分开分别处理。就不存在判断供牌玩家，胡牌玩家了。<br>    自身摸牌时操作，由客户端进行处理。<br>    waitdiscard 阶段，接收客户端发送的 出牌 暗杠，补杠，胡，过操作</p><pre><code class="hljs">别人打出的牌进行操作，根据玩家进行压栈操作。依次压入 胡 碰杠 吃waitcpkh 阶段，接收客户端根据服务器返回操作 而发送的 胡，抢杠胡，碰杠，吃，过操作</code></pre><h1 id="2021-03-11"><a href="#2021-03-11" class="headerlink" title="2021.03.11"></a>2021.03.11</h1><p>上午详细研究 吃碰杠胡算法<br>然后研究框架</p><p>胡牌 去除将牌，去除刻子，看剩余手牌是否可以组成顺子<br>碰牌 当前牌数量是否&gt;=2<br>杠牌 当前牌数量是否==3<br>吃牌 枚举所有情况 123 456 789  9种吃牌情况</p><p>1 23<br>12 3<br>123</p><p>789<br>78 9<br>7 89</p><p>123 789<br>456</p><p>1    2    3    4    5    6    7    8    9<br>1    4    3    1    1    1    1    1    1</p><p>3 2</p>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>麻将</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发环境搭建</title>
    <link href="/2021/03/03/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/03/03/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>2021.03.03</p><hr><ol><li><p>安装开发软件</p><ul><li>Mysql、MongoDB  安装MongoDB的时候，不要勾选Compress</li><li>sublimeText3</li></ul> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 安装PrettyJson<br><span class="hljs-regexp">//</span> 按Ctrl+Shift+p打开命令框，搜索PCI，打开package安装框<br><span class="hljs-regexp">//</span> 搜索PrettyJson，点击条目安装<br><span class="hljs-regexp">//</span> Ctrl+Alt+J就可格式化json数据<br></code></pre></td></tr></table></figure><ul><li>vscode  使用GitHub账号同步插件设置</li><li>navicatPremium</li><li>Git</li><li>svn</li><li>go</li><li>python27</li><li>SourceTree</li><li>WinScp</li><li>Typora</li></ul></li><li><p>配置开发环境</p><ul><li>go<br>  配置gopath<br>  配置代理<br>  配置GO111MODULE</li><li>vscode<br>  vscode相关插件安装(chinese,go,svn…)<br>  安装go相关插件<br>  安装svn，并配置svn.path 路径使用\分隔</li></ul></li></ol><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><hr><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker network create --subnet=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.152</span>/<span class="hljs-number">16</span> --gateway <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> mynetwork<br>docker run -itd --name dgserver --mac-address <span class="hljs-number">00</span>-E0-<span class="hljs-number">6B-68</span>-<span class="hljs-number">05</span>-A7  -v  E:/docker_server/server:/root/server --net mynetwork --ip <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.152</span> centos:centos8 /bin/bash<br></code></pre></td></tr></table></figure><p>Docker安装后，默认会创建下面三种网络类型<br>启动 Docker的时候，用 –network 参数，可以指定网络类型</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -itd <span class="hljs-params">--name</span> test1 <span class="hljs-params">--network</span> bridge <span class="hljs-params">--ip</span> 172.17.0.10 centos<span class="hljs-function">:latest</span> <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure><p>bridge：桥接网络<br>默认情况下启动的Docker容器，都是使用 bridge，Docker安装时创建的桥接网络，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker的IP地址就变了</p><p>none：无指定网络<br>使用 –network=none ，docker 容器就不会分配局域网的IP</p><p>host： 主机网络<br>使用 –network=host，此时，Docker 容器的网络会附属在主机上，两者是互通的。<br>例如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。</p><p>创建自定义网络：（设置固定IP）<br>启动Docker容器的时候，使用默认的网络是不支持指派固定IP的，如下</p><p>步骤1: 创建自定义网络</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">docker network ls<br>NETWORK ID     NAME        DRIVER       <span class="hljs-keyword">SCOPE</span><br><span class="hljs-number">9781</span>b1f585ae    bridge       bridge       <span class="hljs-keyword">local</span><br><span class="hljs-number">1252</span>da701e55    host        host        <span class="hljs-keyword">local</span><br><span class="hljs-number">4</span>f11ae9c85de    mynetwork      bridge       <span class="hljs-keyword">local</span><br><span class="hljs-number">237</span>ea3d5cfbf    <span class="hljs-keyword">none</span>        <span class="hljs-keyword">null</span>        <span class="hljs-keyword">local</span><br></code></pre></td></tr></table></figure><p>步骤2: 创建Docker容器</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -itd <span class="hljs-params">--name</span> networkTest1 <span class="hljs-params">--net</span> mynetwork <span class="hljs-params">--ip</span> 172.18.0.2 centos<span class="hljs-function">:latest</span> <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跑得快算法</title>
    <link href="/2021/02/27/%E8%B7%91%E5%BE%97%E5%BF%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/27/%E8%B7%91%E5%BE%97%E5%BF%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2021-02-27"><a href="#2021-02-27" class="headerlink" title="2021.02.27"></a>2021.02.27</h1><p>var CardValueMap = map[int]int{<br>POKER_EMPTY: -1,<br> 2: 0,<br>  3: 1,<br>   4: 2,<br>    5: 3,<br>     6: 4,<br>      7: 5,<br>       8: 6,<br>        9: 7,</p><pre><code class="hljs">10: 8, 11: 9,  12: 10,   0: 11,    1: 12    &#125;</code></pre><p>// 跑得快,底层数据结构<br> 0    1    2    3    4    5    6    7    8    9    10    11    12    //方片<br> 13    14    15    16    17    18    19    20    21    22    23    24    25    //梅花<br> 26    27    28    29    30    31    32    33    34    35    36    37    38    //红桃<br> 39    40    41    42    43    44    45    46    47    48    49    50    51    //黑桃<br> 52    53    //小王,大王</p><p>card % 13 取模计算得出 牌值切片的索引值</p><p>card % 13 + 1 计算得出牌值<br>根据card值区分花色</p><p>使用链表生成树，实现牌型算法：<br>                                    A<br>                                =========<br>                                |        |<br>                                K        K<br>                            =========<br>                            |        |<br>                            Q        Q<br>                        =========<br>                        |        |<br>                        J        J<br>                    =========<br>                    |        |<br>                    10        10        //实现并非使用二叉树</p><pre><code class="hljs">                                                                            root                                            =====================================================================                                             |                                                                    |    ==================================================================================================        =========    ...依次类推    |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        3        4        5        6        7        8        9        10        J        Q        K        A         2        33  --- 22=========    ...依次类推                                                                                    =========    ...依次类推|        |                                                                                                |        |4  ---  2                                                                                                44  --- 22</code></pre><p>=========<br>|        |                                                                                                …依次类推<br>5  —  2</p><p>…依次类推</p><p>构建出牌树：<br>    1.先排除炸弹<br>    2.从最小牌开始 (递增逐个判断)<br>        A 一张<br>            a.A            找到所有单牌<br>            b.ABCDE        使用所有单牌构建顺子 (从最小单张开始 递增逐个判断)<br>            c.AAAB        找到所有的3张，构建三带一 (从最小3张开始 递增逐个判断)<br>            d.AAABBBCD    使用所有的3张构建飞机带单牌 (从最长的开始)</p><pre><code class="hljs">    B 两张        a.AA         找到所有对子        b.AABB        使用所有对子构建顺子        c.AAABB     找到所有的3张，构建三带二        d.AAABBBCCDD使用所有的3张构建飞机带对牌    C 三张        a.AAABB         找到所有的3张，构建三带二        b.AAABBB         使用所有的三张构建飞机        c.AAABBBCCDD    使用所有的3张构建飞机带对牌    D 四张        a.AAAA    找到所有的4张</code></pre><p>超时自动出牌：<br>    AutoShowCard<br>        getAutoShowCard<br>            首出牌：getBestAutoSuggestCards, 首出最长的牌, 剩余3张和下家报单特殊处理<br>            压牌：getAutoSuggestFunc 首先判断炸弹出牌顺序，相同牌型先出，其次拆牌出，其次出炸弹</p><p>计算树的深度，找出最短的子树：<br>    计算树的最小深度<br>    分析所有叶子节点<br>    计算叶子结点到根节点的路径长度，长度等于最小深度 。即是最短的子树。<br>    计算排序中单牌数量最少的链表<br>    链表排序 按照牌型中最大的牌值    </p>]]></content>
    
    
    <categories>
      
      <category>工作【间歇性记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>跑得快</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linuxCmd</title>
    <link href="/2020/11/25/linuxCmd/"/>
    <url>/2020/11/25/linuxCmd/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./game_private_server -Config=./config/game_config_mjjxhzzm_61.cfg &gt;&gt; <span class="hljs-built_in">log</span>/game_private_server_mjjxhzzm_61.<span class="hljs-built_in">log</span> 2&gt;&amp;1 &amp;<br><br><span class="hljs-built_in">nohup</span> ./game_private_server -Config=./config/game_config_mjhnwxd_61.cfg &gt;&gt; <span class="hljs-built_in">log</span>/game_private_server_mjhnwxdd_61.<span class="hljs-built_in">log</span> 2&gt;&amp;1 &amp;<br><br><span class="hljs-built_in">nohup</span> ./game_private_server -Config=./config/game_config_mjhnayhx_88.cfg mjhnayhx_88 &gt;&gt; <span class="hljs-built_in">log</span>/game_private_server_mjhnayhx_88.<span class="hljs-built_in">log</span> 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>redis 添加测试</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">auth</span> qwe123!@<span class="hljs-comment">#</span><br><span class="hljs-literal">select</span> <span class="hljs-number">9</span><br>hset haunters id <span class="hljs-number">1</span>，<br>HEXISTS haunters<br></code></pre></td></tr></table></figure><p>Redis 设置密码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-built_in">set</span> requirepass password<br>auth password<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">get</span> requirepass<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cmd:<br> <span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> requirepass qwe123!@#<br>  auth qwe123!@#<br> <span class="hljs-built_in"> config </span><span class="hljs-built_in">get</span> requirepass<br></code></pre></td></tr></table></figure><p>optional string PassWord = 3;        // 密码</p><p>  ./protoc.exe –go_out=. ./*.proto</p><p>  “notice#body”</p><p>  624691</p><p>– mysql开启事件命令</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%sche%&#x27;</span>;<br><br><span class="hljs-keyword">set</span> global <span class="hljs-comment">event_scheduler =1</span><br></code></pre></td></tr></table></figure><p>天天 userid 406570</p><p>// ssh连接服务器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> ssh root@<span class="hljs-number">39.100.68.248</span><br></code></pre></td></tr></table></figure><p>// 上传文件到服务器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo scp <span class="hljs-regexp">/Users/</span>xinyi-jin<span class="hljs-regexp">/Desktop/</span>test.txt root@<span class="hljs-number">39.100</span>.<span class="hljs-number">68.248</span>:<span class="hljs-regexp">/root/</span>server/<br></code></pre></td></tr></table></figure><p>// 上传文件到服务器，不会影响当前正在运行的程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rsync -av <span class="hljs-regexp">/Users/</span>xinyi-jin<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/jxserver/</span>bin<span class="hljs-regexp">/xiangque/</span>* root@<span class="hljs-number">39.100</span>.<span class="hljs-number">68.248</span>:<span class="hljs-regexp">/root/</span>server<br></code></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">cygwin错误 <br>原因：ssh.exe可能会与git下边的版本冲突<br>解决办法：可使用-e参数指定ssh.exe<br><br>rsync -av -e <span class="hljs-symbol">D:</span>\soft\cwrsync_6.<span class="hljs-number">2.4_</span>x64_free\bin\ssh.exe robot/robot root<span class="hljs-variable">@47</span>.<span class="hljs-number">107.37</span>.<span class="hljs-number">120</span><span class="hljs-symbol">:/root/%</span><span class="hljs-number">1</span>/robot/<br></code></pre></td></tr></table></figure><p>// mac 交叉编译linux</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build gripper.go<br></code></pre></td></tr></table></figure><p>Gitshell中输入如下命令解决：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git config --global core.<span class="hljs-built_in">auto</span>crlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>Go 自动生成测试文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">gotests -<span class="hljs-keyword">only</span> IntToRoman -<span class="hljs-keyword">w</span> intToRoman.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>WinSCP命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./WinSCP.com</span>   进入winscp命令行<br>open sftp:<span class="hljs-string">//root</span>@47.107.37.120 -privatekey=C:\Users\Administrator\<span class="hljs-string">.ssh</span>\id_rsa.ppk   连接远端<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows安装软件</title>
    <link href="/2020/11/25/windows_soft/"/>
    <url>/2020/11/25/windows_soft/</url>
    
    <content type="html"><![CDATA[<h2 id="windows-安装软件列表"><a href="#windows-安装软件列表" class="headerlink" title="windows 安装软件列表"></a>windows 安装软件列表</h2><h3 id="1-视频剪辑类："><a href="#1-视频剪辑类：" class="headerlink" title="1.视频剪辑类："></a>1.视频剪辑类：</h3><ul><li>flash</li><li>格式工厂</li><li>PopPlayer</li></ul><h3 id="2-远程控制："><a href="#2-远程控制：" class="headerlink" title="2.远程控制："></a>2.远程控制：</h3><ul><li>TeamViewer</li><li>向日葵</li></ul><h3 id="3-屏幕保护："><a href="#3-屏幕保护：" class="headerlink" title="3.屏幕保护："></a>3.屏幕保护：</h3><ul><li>护眼宝</li></ul><h3 id="4-驱动系列："><a href="#4-驱动系列：" class="headerlink" title="4.驱动系列："></a>4.驱动系列：</h3><ul><li>MSI官网 Ge72 6QF相关驱动软件</li></ul><h3 id="5-办公系列："><a href="#5-办公系列：" class="headerlink" title="5.办公系列："></a>5.办公系列：</h3><ul><li>WPS Office</li><li>有道词典</li></ul><h3 id="6-翻墙VPN："><a href="#6-翻墙VPN：" class="headerlink" title="6.翻墙VPN："></a>6.翻墙VPN：</h3><ul><li>蓝灯 lantern</li><li>自由门</li></ul><h3 id="7-浏览器"><a href="#7-浏览器" class="headerlink" title="7.浏览器"></a>7.浏览器</h3><ul><li>谷歌浏览器</li><li>油猴相关插件</li></ul><h3 id="8-开发相关"><a href="#8-开发相关" class="headerlink" title="8.开发相关"></a>8.开发相关</h3><ul><li>必备软件</li><li>VSCode</li><li>Git</li><li>MySQL</li><li>MongoDB</li><li>Redis</li><li>SubineText<ul><li>可根据需要选装</li><li>OpenSSH-win64  ssh工具</li><li>运行Game使用Python27,3版本的不支持</li><li>XShell</li><li>Xftp</li><li>winscp</li><li>explore++</li><li>……</li></ul></li></ul><h3 id="9-输入法"><a href="#9-输入法" class="headerlink" title="9.输入法"></a>9.输入法</h3><ul><li>搜狗输入法</li></ul><h3 id="10-聊天交流"><a href="#10-聊天交流" class="headerlink" title="10.聊天交流"></a>10.聊天交流</h3><ul><li>QQ</li><li>微信</li></ul><h3 id="11-文件搜索、编辑、备份、解压工具"><a href="#11-文件搜索、编辑、备份、解压工具" class="headerlink" title="11.文件搜索、编辑、备份、解压工具"></a>11.文件搜索、编辑、备份、解压工具</h3><ul><li>Typora</li><li>Listary</li><li>百度云盘</li><li>winRAR</li></ul><h3 id="12-截图软件"><a href="#12-截图软件" class="headerlink" title="12.截图软件"></a>12.截图软件</h3><ul><li>Snipaste（支持Windows和Mac ，多截屏贴图）</li></ul><h3 id="13-抓包工具"><a href="#13-抓包工具" class="headerlink" title="13.抓包工具"></a>13.抓包工具</h3><ul><li>wires hark 推荐</li><li>burp</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin web开发入门</title>
    <link href="/2020/08/29/Gin-web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/29/Gin-web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>Day01 简单部署Gin框架</li><li>ps：首次执行的时候我是mac默认的go 1.12版本，然后就很多错误。后来换成go 1.14.5版本，执行下方教程就好啦。</li></ul><ol><li>安装Go语言开发环境<br>使用mac命令行，brew工具直接安装，代码如下：</li></ol><p><code>brew install go</code></p><p>运行完成没有报错就是安装成功</p><ol start="2"><li>安装Gin框架<br>使用官方提供的命令安装。（前提：需要设置go全局的path变量，自行查找方案，不做过多介绍）</li></ol><p><code>go get -u github.com/gin-gonic/gin</code></p><p>这里直接运行命令的话会出现 连接超时报错。因为get的资源中包含一些其他的资源引用，这部分正好处于google包中或其他国内不能访问的包中。<br>解决方法：<br>设置GOPROXY变量，用于获取这部分资源，然后get到本地。</p><p>使用 go env 命令查看 GOPROXY变量的值。<br>执行以下命令，打开modules 然后设置goproxy代理</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">go env -w <span class="hljs-attribute">GO111MODULE</span>=on<br>go env -w <span class="hljs-attribute">GOPROXY</span>=https://goproxy.io,direct<br></code></pre></td></tr></table></figure><p>完成上述操作后，再执行第一步的go get命令，没有报错就证明下载成功。可以到gopath目录下查找gin包。</p><ol start="3"><li>部署Gin 简单web页面<br>首先，构建go源码文件，导入gin包</li></ol><p><code>import &quot;github.com/gin-gonic/gin&quot;</code><br>然后根据官网给的example，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，执行go run xxx.go执行<br>注意：最后执行的时候大概率会报错</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">main.go:<span class="hljs-number">3</span>:<span class="hljs-number">8</span>: cannot find <span class="hljs-keyword">module</span> providing <span class="hljs-keyword">package</span> github.com/gin-gonic/gin: working directory <span class="hljs-keyword">is</span> not part <span class="hljs-keyword">of</span> a <span class="hljs-keyword">module</span><br></code></pre></td></tr></table></figure><p>具体原因是因为go mod 本身的资源管理问题，在开启modules的时候，资源路径改变，导致不能正确访问到gin包。导致go代码中 import 的时候没有引入gin包。</p><p>解决方法：在当前执行代码的目录下，执行以下命令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> init gin <br><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> <span class="hljs-keyword">edit</span> -require github.<span class="hljs-keyword">com</span>/gin-gonic/gin@latest<br></code></pre></td></tr></table></figure><p>这个好像是类似于nodejs的npm包管理工具，了解不多不做过多描述，以免误导各位。</p><p>小技巧：使用go build 的时候可以使用-o参数指定生成的文件名称<br>gin_test 自定义的生成文件名称<br>gin_demo.go程序源代码</p><p><code>go build -o gin_test gin_demo.go</code></p><p>关于Gin API方面，官网提供Using GET, POST, PUT, PATCH, DELETE and OPTIONS</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-comment">// Creates a gin router with default middleware:</span><br><span class="hljs-comment">// logger and recovery (crash-free) middleware</span><br>router := gin<span class="hljs-selector-class">.Default</span>()<br><br>router<span class="hljs-selector-class">.GET</span>(<span class="hljs-string">&quot;/someGet&quot;</span>, getting)<br>router<span class="hljs-selector-class">.POST</span>(<span class="hljs-string">&quot;/somePost&quot;</span>, posting)<br>router<span class="hljs-selector-class">.PUT</span>(<span class="hljs-string">&quot;/somePut&quot;</span>, putting)<br>router<span class="hljs-selector-class">.DELETE</span>(<span class="hljs-string">&quot;/someDelete&quot;</span>, deleting)<br>router<span class="hljs-selector-class">.PATCH</span>(<span class="hljs-string">&quot;/somePatch&quot;</span>, patching)<br>router<span class="hljs-selector-class">.HEAD</span>(<span class="hljs-string">&quot;/someHead&quot;</span>, head)<br>router<span class="hljs-selector-class">.OPTIONS</span>(<span class="hljs-string">&quot;/someOptions&quot;</span>, options)<br><br><span class="hljs-comment">// By default it serves on :8080 unless a</span><br><span class="hljs-comment">// PORT environment variable was defined.</span><br>router<span class="hljs-selector-class">.Run</span>()<br><span class="hljs-comment">// router.Run(&quot;:3000&quot;) for a hard coded port</span><br>&#125;<br></code></pre></td></tr></table></figure><p>值得一提的是，通过网址访问<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> 默认使用的get请求，用其他的都会404，应该是前端请求时候要指定是post或者delete或其他的请求才能正确访问到。</p><p>好像是根据RESTful API接口风格来定义的，感兴趣的可以看下阮一峰老师的博文：<br>RESTful API 设计指南</p><p>在这里的话如果我们想要看其他请求的效果，可以使用postman api测试，选择请求方式，填写url地址就可以发起请求，然后看到返回的数据。</p><p>Gin框架官方文档：<a href="https://gin-gonic.com/docs/">https://gin-gonic.com/docs/</a>.</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoLang中if临时变量的生存周期</title>
    <link href="/2020/03/25/GoLang%E4%B8%ADif%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/03/25/GoLang%E4%B8%ADif%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>进行了下方代码进行验证</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span> n:=<span class="hljs-number">1</span>+<span class="hljs-number">1</span>;n!=<span class="hljs-number">2</span>&#123;<br>fmt.Print(<span class="hljs-string">&quot;if n:&quot;</span>,n)<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">2</span>&#123;<br>fmt.Print(<span class="hljs-string">&quot;else if n:&quot;</span>,n)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>fmt.Print(<span class="hljs-string">&quot;else n:&quot;</span>,n)<br>&#125;<br><span class="hljs-comment">// fmt.Print(&quot;n:&quot;,n)</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：<br><code>else n:2</code></p><p>总结，由代码执行结果可得：if 判断条件中临时定义的变量，其生命周期存在于整个if else语句逻辑中，不管是if分支逻辑还是else分支逻辑。注意：在if else外则直接会提示 undefined: n</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go int类型转string类型</title>
    <link href="/2020/03/25/int%E7%B1%BB%E5%9E%8B%E8%BD%ACstring%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/03/25/int%E7%B1%BB%E5%9E%8B%E8%BD%ACstring%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>版权声明：本文为CSDN博主「duzhenxun」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/duzhenxun/article/details/95739946">https://blog.csdn.net/duzhenxun/article/details/95739946</a></p><p>2个值做对比时要先注意他们的类型.如果一个string与一个in32不能直接对比.先要转换类型</p><p>如果使用Itoa需要一个int,使用FormatInt需要一个int64,</p><p>最简单的方法是使用fmt.Sprint(int32),但效率比较低</p><ol><li>fmt.Sprint(i) 比较慢</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">Sprint</span>(<span class="hljs-selector-tag">a</span> ...interface&#123;&#125;) string &#123;<br>    <span class="hljs-selector-tag">p</span> := <span class="hljs-built_in">newPrinter</span>()<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.doPrint</span>(a)<br>    s := <span class="hljs-built_in">string</span>(<span class="hljs-selector-tag">p</span>.buf)<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.free</span>()<br>    return s<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>strconv.Itoa(int(i))</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Itoa(<span class="hljs-params">i</span> <span class="hljs-params">int</span>)</span> <span class="hljs-built_in">string</span> &#123;<br>    return <span class="hljs-constructor">FormatInt(<span class="hljs-params">int64</span>(<span class="hljs-params">i</span>)</span>, <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">strconv.FormatInt(<span class="hljs-type">int64</span>(i), <span class="hljs-number">10</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FormatInt</span><span class="hljs-params">(i <span class="hljs-type">int64</span>, base <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    _, s := formatBits(<span class="hljs-literal">nil</span>, <span class="hljs-type">uint64</span>(i), base, i &lt; <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>string转成int：</li></ol><p><code>int, err := strconv.Atoi(string)</code></p><ol start="5"><li>string转成int64：</li></ol><p><code>int64, err := strconv.ParseInt(string, 10, 64)</code></p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中WHERE子句不等于的使用</title>
    <link href="/2020/03/17/MySQL%E4%B8%ADWHERE%E5%AD%90%E5%8F%A5%E4%B8%8D%E7%AD%89%E4%BA%8E%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/03/17/MySQL%E4%B8%ADWHERE%E5%AD%90%E5%8F%A5%E4%B8%8D%E7%AD%89%E4%BA%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>MySQL中WHERE子句条件判断&lt;&gt;，!= 二者的区别<br>ANSI标准中是用&lt;&gt;(所以建议用&lt;&gt;)，但为了跟大部分数据库保持一致，数据库中一般都提供了 !=(高级语言一般用来表示不等于) 与 &lt;&gt; 来表示不等于：</p><ul><li>MySQL 5.1: 支持 != 和 &lt;&gt;</li><li>PostgreSQL 8.3: 支持 != 和 &lt;&gt;</li><li>SQLite: 支持 != 和 &lt;&gt;</li><li>Oracle 10g: 支持 != 和 &lt;&gt;</li><li>Microsoft SQL Server 2000/2005/2008: 支持 != 和 &lt;&gt;</li><li>IBM Informix Dynamic Server 10: 支持 != 和 &lt;&gt;</li><li>InterBase/Firebird: 支持 != 和 &lt;&gt;</li></ul><p>最后两个只支持ANSI标准的数据库：</p><ul><li>IBM DB2 UDB 9.5:仅支持 &lt;&gt;</li><li>Apache Derby:仅支持 &lt;&gt;</li></ul><p>建议使用&lt;&gt;标识不等于关系，这样适配所有的数据库</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>产品更新相关</title>
    <link href="/2020/03/17/%E4%BA%A7%E5%93%81%E6%9B%B4%E6%96%B0%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/03/17/%E4%BA%A7%E5%93%81%E6%9B%B4%E6%96%B0%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="产品更新迭代注意事项："><a href="#产品更新迭代注意事项：" class="headerlink" title="产品更新迭代注意事项："></a>产品更新迭代注意事项：</h3><hr><ol><li><p>版本兼容<br>新版本要兼容老版本，因为服务器与客户端更新不同步的话，会导致老版本不能正常使用（这里指的是不停机更新，不讨论其他情况）</p><ul><li>服务器更新后，客户端没有及时更新，导致老版本出错</li><li>客户端更新后，服务器没有及时更新，导致客户端更新内容不能使用</li></ul><p>解决方案：</p></li></ol><p>​        一般都是服务器先更新后台逻辑代码，并兼容老版本的逻辑，然后客户端更新，正常使用新增逻辑（客户端强制更新），用户体验上来说没有什么差别，等到下次更新客户端的时候就可以把为了兼容老版本的多余代码移除掉。</p><ol start="2"><li>其他内容待添加</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>产品更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除windows脚本cmd小黑框</title>
    <link href="/2020/03/17/%E5%8E%BB%E9%99%A4windows%E8%84%9A%E6%9C%ACcmd%E5%B0%8F%E9%BB%91%E6%A1%86/"/>
    <url>/2020/03/17/%E5%8E%BB%E9%99%A4windows%E8%84%9A%E6%9C%ACcmd%E5%B0%8F%E9%BB%91%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<p>去除windows bat或cmd命令的小黑框</p><ol><li>新建文件保存为run.vbs,example.cmd 是要执行的脚本</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">Set</span> ws = CreateObject(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>)    <br>ws.<span class="hljs-built_in">run</span> <span class="hljs-string">&quot;cmd /c C:\IIMS\serverscmd\example.cmd&quot;</span>,0<br></code></pre></td></tr></table></figure><p>参考： weixin_30723433老哥</p><ol start="2"><li>不适用vb，调用脚本，在脚本中直接指定</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//autoStart.bat</span><br><span class="hljs-variable">@echo</span> off <br>if <span class="hljs-string">&quot;%1&quot;</span> == <span class="hljs-string">&quot;h&quot;</span> goto begin <br>mshta <span class="hljs-attribute">vbscript</span>:<span class="hljs-built_in">createobject</span>(<span class="hljs-string">&quot;wscript.shell&quot;</span>).<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;%~nx0&quot;</span><span class="hljs-string">&quot; h&quot;</span>,<span class="hljs-number">0</span>)(window.close)&amp;&amp;<span class="hljs-attribute">exit </span><br><span class="hljs-attribute"></span>:begin <br><span class="hljs-comment">//上面是添加隐藏黑框框的</span><br><span class="hljs-comment">//下面放自己脚本需要执行的命令</span><br></code></pre></td></tr></table></figure><p>ps:这种在脚本中直接关闭黑框的方法，如果启动多个程序的时候，就会提示脚本错误。（注意点自己的需求就好）</p><p>参考： weixin_30648587老哥</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go func</title>
    <link href="/2020/03/01/goFunc/"/>
    <url>/2020/03/01/goFunc/</url>
    
    <content type="html"><![CDATA[<h2 id="2020-03-01"><a href="#2020-03-01" class="headerlink" title="2020.03.01"></a>2020.03.01</h2><p>golang 匿名函数</p><p>​    可赋值给变量，使用变量名调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>f:=<span class="hljs-built_in">func</span>()&#123;<br><br>...<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>​    闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span>&#123;<br><br>...<br><br>&#125;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>​    匿名函数用作回调函数</p><p>​    // 遍历切片的每个元素, 通过给定函数进行元素访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br><br> <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br><br>   f(v)<br><br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  // 使用匿名函数打印切片内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">visit([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> &#123;<br><br>  fmt.Println(v)<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>​    封装匿名函数，实现动态调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> fMap = map<span class="hljs-selector-attr">[string]</span>&#123;<br><br><span class="hljs-string">&quot;temp&quot;</span> : <span class="hljs-built_in">func</span>(<span class="hljs-selector-tag">a</span> int)&#123;<br><br>...<br><br>&#125;<br><br>&#125;<br><br><br><br>f := fMap<span class="hljs-selector-attr">[<span class="hljs-string">&quot;temp&quot;</span>]</span><br><br><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL按天建表</title>
    <link href="/2020/01/02/MySQL%E6%8C%89%E5%A4%A9%E5%BB%BA%E8%A1%A8/"/>
    <url>/2020/01/02/MySQL%E6%8C%89%E5%A4%A9%E5%BB%BA%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>mysql设置定时任务：</p><p>需求：mysql数据库里面做个定时任务自动每天创建一张表。</p><ol><li>查看是否开启event与开启event</li></ol><p><code>show variables like &#39;%sche%&#39;;  </code></p><p>若未开启</p><p><code>set global event_scheduler =1;</code></p><ol start="2"><li>创建存储过程</li></ol><p>每天创建一个名为 test_年月日的表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delimiter</span> //<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">procedure</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> create_table01//<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> create_table01()<br><br><span class="hljs-keyword">BEGIN</span><br><br><span class="hljs-keyword">declare</span> str_date <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">SET</span> str_date = date_format(now(),<span class="hljs-string">&#x27;%Y%m%d&#x27;</span>);  <br><br> <br><br><span class="hljs-keyword">SET</span> @sqlcmd1 = CONCAT(<span class="hljs-string">&#x27;CREATE TABLE test_&#x27;</span>,str_date,<span class="hljs-string">&#x27;(</span><br><span class="hljs-string"></span><br><span class="hljs-string">id int(11) not null auto_increment primary key,</span><br><span class="hljs-string"></span><br><span class="hljs-string">time datetime not null</span><br><span class="hljs-string"></span><br><span class="hljs-string">) ;&#x27;</span>);<br><br><span class="hljs-keyword">PREPARE</span> p1 <span class="hljs-keyword">FROM</span> @sqlcmd1;<br><br><span class="hljs-keyword">EXECUTE</span> p1;<br><br><span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> p1;<br><br><span class="hljs-keyword">END</span>//<br><br><span class="hljs-keyword">delimiter</span> ;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建事件，调用存储过程</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">drop <span class="hljs-keyword">event</span> <span class="hljs-keyword">if</span> exists test_event01;<br><br>create <span class="hljs-keyword">event</span> test_event01<br><br><span class="hljs-keyword">on</span> schedule every <span class="hljs-number">1</span> <span class="hljs-function">DAY STARTS <span class="hljs-title">NOW</span>()</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">do</span> call <span class="hljs-title">create_table01</span>()</span>;<br></code></pre></td></tr></table></figure><p>开启事件</p><p><code>alter event test_event on completion preserve enable;</code></p><p><code>show tables;</code></p><p>查询是否建表成功</p><p>若是想关闭事件：</p><p><code>alter event test_event on completion preserve disable;</code></p><ol start="4"><li>事件执行时间的设置</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CREATE</span> EVENT test_event01 <span class="hljs-literal">ON</span> SCHEDULE EVERY <span class="hljs-number">1</span> DAY STARTS &#x27;<span class="hljs-number">2012</span>-<span class="hljs-number">09</span>-<span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&#x27;<br><br><span class="hljs-attribute">ON</span> COMPLETION PRESERVE ENABLE DO CALL  create_table01();<br><br><span class="hljs-attribute">EVERY</span> #后面的是时间间隔，可以选 <span class="hljs-number">1</span> second，<span class="hljs-number">3</span> minute，<span class="hljs-number">5</span> hour，<span class="hljs-number">9</span> day，<span class="hljs-number">1</span> month，<span class="hljs-number">1</span> quarter（季度），<span class="hljs-number">1</span> year<br><br><span class="hljs-comment">#从2013年1月13号0点开始，每天运行一次</span><br><br><span class="hljs-attribute">ON</span> SCHEDULE EVERY <span class="hljs-number">1</span> DAY   STARTS &#x27;<span class="hljs-number">2013</span>-<span class="hljs-number">01</span>-<span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&#x27;<br><br><span class="hljs-comment">#从现在开始每隔九天定时执行</span><br><br><span class="hljs-attribute">ON</span> SCHEDULE EVERY <span class="hljs-number">9</span> DAY STARTS NOW() ；<br><br><span class="hljs-comment">#每个月的一号凌晨1 点执行</span><br><br><span class="hljs-attribute">on</span> schedule every <span class="hljs-number">1</span> month starts date_add(date_add(date_sub(curdate(),interval day(curdate())-<span class="hljs-number">1</span> day),interval <span class="hljs-number">1</span> month),interval <span class="hljs-number">1</span> hour);<br><br><span class="hljs-comment">#每个季度一号的凌晨1点执行</span><br><br><span class="hljs-attribute">on</span> schedule every <span class="hljs-number">1</span> quarter starts date_add(date_add(date(concat(year(curdate()),&#x27;-&#x27;,elt(quarter(curdate()),<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>),&#x27;-&#x27;,<span class="hljs-number">1</span>)),interval <span class="hljs-number">1</span> quarter),interval <span class="hljs-number">1</span> hour);<br><br><span class="hljs-comment">#每年1月1号凌晨1点执行</span><br><br><span class="hljs-attribute">on</span> schedule every <span class="hljs-number">1</span> quarter starts date_add(date_add(date(concat(year(curdate()),&#x27;-&#x27;,elt(quarter(curdate()),<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>),&#x27;-&#x27;,<span class="hljs-number">1</span>)),interval <span class="hljs-number">1</span> quarter),interval <span class="hljs-number">1</span> hour);<br></code></pre></td></tr></table></figure><ol start="5"><li>几个相关概念</li></ol><p>存储程序：( 存储函数(stored function)+存储过程(stored procedure)+触发器(trigger)+事件(event) )</p><p>存储函数：返回一个计算结果，该结果可以用在表达式里</p><p>存储过程：不直接返回一个结果，但可以用来完成一般的运算或是生成一个结果集并传递会客户</p><p>触发器：与数据表关联，当那个数据表被 insert、delete、update语句修改时，触发器将自动执行</p><p>事件：根据时间表在预订时刻自动执行</p><p>原文地址：<a href="https://blog.csdn.net/vinking9393/article/details/84805050">https://blog.csdn.net/vinking9393/article/details/84805050</a></p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制某位数0变1，1变0</title>
    <link href="/2019/12/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9F%90%E4%BD%8D%E6%95%B00%E5%8F%981%EF%BC%8C1%E5%8F%980/"/>
    <url>/2019/12/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9F%90%E4%BD%8D%E6%95%B00%E5%8F%981%EF%BC%8C1%E5%8F%980/</url>
    
    <content type="html"><![CDATA[<p>二进制操作（使用Go语言实现）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 把第三位修改为0，标识没有在线奖励可以领取</span><br>replyStatus.Status = replyStatus.Status <span class="hljs-meta">&amp;^ (1 &lt;&lt; 2) </span><br><br><span class="hljs-comment">// 把第三位修改为1，标识有在线奖励未领取</span><br>reply.Status <span class="hljs-string">|= (1 &lt;&lt; 2) </span><br><br><span class="hljs-comment">// 把binar的二进制数，第n+1位设置成1</span><br>binar <span class="hljs-string">|  (1&lt;&lt;n) </span><br><br><span class="hljs-comment">// 把binar的二进制数，第n+1位设置成0</span><br>binar <span class="hljs-meta">&amp;^ (1 &lt;&lt; n) </span><br><br><span class="hljs-comment">// 在Go中实际使用,如需改变原数,可直接使用如下形式</span><br>binar <span class="hljs-string">|=  (1&lt;&lt;n) </span><br>binar <span class="hljs-meta">&amp;= ^(1 &lt;&lt; n) </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL57的安装与使用</title>
    <link href="/2019/12/01/MySQL57%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/12/01/MySQL57%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>下载安装MySQL57</li></ul><ol><li>去官网下载MySQL57的安装包，<a href="https://dev.mysql.com/downloads/installer/">https://dev.mysql.com/downloads/installer/</a><br>不选择最新版本，点击选择其他版本</li></ol><p>点击下载</p><p>选择只开始我的下载</p><p>下载完成后，双击可运行程序<br>ps：安装过程中，能next的地方就next，这种界面就暂不提供截图分享了</p><p>设置数据库使用的端口号</p><p>设置数据库的密码</p><p>设置数据库的DOS命令启动名称</p><p>等待安装完成后Execute，然后finish就安装好了</p><p>输入用户名密码，连接到数据库，这里默认的是root最高权限账户</p><ul><li>DOS简单使用MySQL57<br>使用DOS命令操作数据库之前先要配置好MySQL的环境变量，同jdk的配置方式一样</li></ul><p>ps：经过install安装工具连接成功之后就不用再使用下边的DOS命令，应为服务已经启动了</p><p>MySQL服务安装</p><p><code>mysqld -install</code></p><p>启动MySQL数据库</p><p><code>net start mysql</code></p><p>关闭MySQL数据库</p><p><code>net stop mysql</code></p><p>连接数据库（-h 数据库的IP地址，-u用户名 -p密码）</p><p><code>mysql -h 127.0.0.1 -u root  -p</code></p><p>ps:进入数据库之后就可以使用标准SQL语句去执行，dos下密码的输入是隐式的，就是说你输密码的时候自己看不到，只要输入后回车就可以了</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Go在windows编译linux可执行文件</title>
    <link href="/2019/12/01/%E7%94%A8Go%E5%9C%A8windows%E7%BC%96%E8%AF%91linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <url>/2019/12/01/%E7%94%A8Go%E5%9C%A8windows%E7%BC%96%E8%AF%91linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>用Go在windows编译linux可执行文件</p><p>一、配置好windows下的Go环境<br>    <code>GOPATH   GOROOT</code></p><p>二、进入CMD命令窗口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br><span class="hljs-built_in">SET</span><span class="hljs-attribute">GOOS</span>=linux<br></code></pre></td></tr></table></figure><p>注意： “=”两边不要留空格，否则会修改参数失败，编译出来的还是window下的可执行文件。具体原因我也不清楚，不加空格就对了。</p><p>三、编译文件<br>    <code>go build XXX.go</code></p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Windows</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven的安装</title>
    <link href="/2019/12/01/maven%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/12/01/maven%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<ul><li>下载maven<br>先去官网下载maven的压缩包文件<br><a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></li></ul><p>下载到本地之后，直接解压到目录文件中即可，然后配置maven的环境变量，这里就不多说了</p><p>然后DOS命令执行</p><p><code>mvn -v</code></p><p>显示下边的信息就证明maven安装好了</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令的简单使用</title>
    <link href="/2019/03/06/Git%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/03/06/Git%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>下载Git<br>windows版本下载地址：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a><br>其他版本可以去 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>下载GUI Client 图形化界面工具（比如：SourceTree）<br>下载好后双击运行，我才用的傻瓜式安装，直接NEXT就好。其中有一个默认的文本编辑方式，vim（使用方法和linux一样）。</li></ul><p>安装好后，就可以右键桌面—&gt;Git Bash Heare 打开命令窗口了<br>打开之后的效果：</p><ul><li>创建GitHub远程仓库<br>注册GitHub账号，地址：<a href="https://github.com/">https://github.com/</a><br>创建Git仓库<br>然后保存这里的连接用于连接远程仓库地址<br>三、使用Git连接远程仓库<br>打开Git命令行窗口，克隆远程仓库</li></ul><p><code>git clone https://github.com/xinyi-jin/test.git</code></p><p>后边的链接指的是上一步复制的远程仓库地址<br>经过上边的操作，就可以把远程仓库的东西复制到本地，因为我是刚刚创建的远程仓库，还没来得及放东西，所以就提示我克隆的是一个空目录</p><p>进入克隆好的本地仓库目录，添加需要上传的文件到暂存区</p><p><code>git add .</code></p><p>add 后边的“.”代表本目录下所有的文件 </p><p>提交暂存区中修改的信息到本地版本库中</p><p><code>git commit -m &quot;test commit&quot;</code></p><p>-m 指的是提交信息的描述</p><p>4.最后提交本地修改到远程仓库</p><p><code>git push -u origin master</code></p><p>ps:这一步操作需要输入GitHub的账号密码。origin 和master 为默认信息<br>使用git status可以查看当前本地仓库文件的状态</p><p>四、查看GitHub远程仓库</p><p>GitHub源码：<a href="https://github.com/xinyi-jin/">https://github.com/xinyi-jin/</a></p><p>ps:部分浏览器不支持，会显示日期错误</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS两个日期之间计算时间差</title>
    <link href="/2019/03/06/JS%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE/"/>
    <url>/2019/03/06/JS%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<ul><li>计算两个日期之间相差的毫秒数（也就是两个日期的时间戳差）<br>这里有几种常见的JS方式，来获得日期的毫秒数。</li></ul><ol><li><p>日期对象的 getTime();方法</p></li><li><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&lt;script&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">//新建一个日期对象，默认现在的时间</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">timestamp</span> = <span class="hljs-built_in">date</span>.getTime();<span class="hljs-comment">//调用getTime()方法获取毫秒数</span><br>alert(<span class="hljs-string">&quot;timestamp: &quot;</span>+<span class="hljs-built_in">timestamp</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>日期对象的valueOf();方法</p></li><li><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&lt;script&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">//新建一个日期对象，默认现在的时间</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">timestamp</span> = <span class="hljs-built_in">date</span>.valueOf(<span class="hljs-built_in">date</span>); <span class="hljs-comment">//调用valueOf()方法获取毫秒数</span><br>alert(<span class="hljs-string">&quot;timestamp: &quot;</span>+<span class="hljs-built_in">timestamp</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>Date对象的parse();方法</p></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&lt;script&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">//新建一个日期对象，默认现在的时间</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">timestamp</span> = <span class="hljs-built_in">Date</span>.parse(<span class="hljs-built_in">date</span>);<span class="hljs-comment">//使用Date对象的parse()方法，获取毫秒数</span><br>alert(<span class="hljs-string">&quot;timestamp: &quot;</span>+<span class="hljs-built_in">timestamp</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>用现在时间的毫秒数减去过去时间的毫秒数，得到的就是两个日期相差的总毫秒数。<br>ps：可以使用上述的三种方法，另外还有一种最为简单的方法。如果两个日期对象都是Date类型的话，可以直接相减，得到的就是毫秒数差。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> new_date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">//新建一个日期对象，默认现在的时间</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> old_date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2018-12-12 00:00:00&quot;</span>); <span class="hljs-comment">//设置过去的一个时间点，&quot;yyyy-MM-dd HH:mm:ss&quot;格式化日期</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> difftime = new_date - old_date; <span class="hljs-comment">//计算时间差</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;difftime: &quot;</span>+difftime);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>得到了两个日期的毫秒差之后，就可以转化成具体的日期格式（xxxx年xx月xx天，xx小时xx分钟xx秒）<br>因为我们获取的是毫秒，所有要先转换成秒。1秒=1000毫秒</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> new_date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">//新建一个日期对象，默认现在的时间</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> old_date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2018-12-12 00:00:00&quot;</span>); <span class="hljs-comment">//设置过去的一个时间点，&quot;yyyy-MM-dd HH:mm:ss&quot;格式化日期</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> difftime = (new_date - old_date)/<span class="hljs-number">1000</span>; <span class="hljs-comment">//计算时间差,并把毫秒转换成秒</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> days = <span class="hljs-built_in">parseInt</span>(difftime/<span class="hljs-number">86400</span>); <span class="hljs-comment">// 天  24*60*60*1000 </span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> hours = <span class="hljs-built_in">parseInt</span>(difftime/<span class="hljs-number">3600</span>)-<span class="hljs-number">24</span>*days;    <span class="hljs-comment">// 小时 60*60 总小时数-过去的小时数=现在的小时数 </span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> minutes = <span class="hljs-built_in">parseInt</span>(difftime%<span class="hljs-number">3600</span>/<span class="hljs-number">60</span>); <span class="hljs-comment">// 分钟 -(day*24) 以60秒为一整份 取余 剩下秒数 秒数/60 就是分钟数</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> seconds = <span class="hljs-built_in">parseInt</span>(difftime%<span class="hljs-number">60</span>);  <span class="hljs-comment">// 以60秒为一整份 取余 剩下秒数</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;时间差是: &quot;</span>+days+<span class="hljs-string">&quot;天, &quot;</span>+hours+<span class="hljs-string">&quot;小时, &quot;</span>+minutes+<span class="hljs-string">&quot;分钟, &quot;</span>+seconds+<span class="hljs-string">&quot;秒&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另外本人踩过坑的一个项目，还是从网上获取的别人的代码，不曾想还是个有bug的项目。<br>1<br>当时这种方式设置日期，然后再获取毫秒数，就会出现30天的时间差。后来干脆直接格式化一下日期放进去，没想到就对了。我也很懵比，有知道的大牛，可以告知一下这样做为什么会好，万分感谢！！！</p><p>GitHub源码：<a href="https://github.com/xinyi-jin/Romantic-confession">https://github.com/xinyi-jin/Romantic-confession</a></p><p>ps:部分浏览器不支持，会显示日期错误</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
      <tag>Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网站标签页如何添加左边的小图标</title>
    <link href="/2019/02/28/%E7%BD%91%E7%AB%99%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%B0%8F%E5%9B%BE%E6%A0%87/"/>
    <url>/2019/02/28/%E7%BD%91%E7%AB%99%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%B0%8F%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>一、首先需要制作一个ico小图标</p><p>可以去阿里云矢量图库，找一张自己喜欢的图标（图标大小：128x128）链接：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p>下载的格式推荐png，可以在线转换.ico格式。在线转换地址：<a href="http://www.favicon-icon-generator.com/?tdsourcetag=s_pcqq_aiomsg">http://www.favicon-icon-generator.com/?tdsourcetag=s_pcqq_aiomsg</a><br>ps：下载好后的图片可以重命名，但是后缀名千万不能改，不然就不能用了…</p><p>二、需要将制作好的ico小图标放到项目的根目录下</p><p>三、需要在要显示图标的页面，head标签中加入</p><p><code>&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;pig.ico&quot; /&gt;</code></p><p>保存文件，重新打开页面就好了</p><p>四、如果需要发布到服务器上，直接使用文件传输工具上传就可以了</p><p>ps：上传文件之后访问，如果不显示的话，就重启一下服务再试试。</p>]]></content>
    
    
    <categories>
      
      <category>学习【资料整理记录】</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
